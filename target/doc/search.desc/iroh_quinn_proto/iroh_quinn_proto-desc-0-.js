searchState.loadedDescShard("iroh_quinn_proto", 0, "Low-level protocol logic for the QUIC protoocol\nthe endpoint has reached the confidentiality or integrity …\nthe application or application protocol caused the …\nError type for attempting to accept an <code>Incoming</code>\nParameters for controlling the peer’s acknowledgement …\nReason given by an application for closing the connection\nThe peer closed the connection\nAt least one new stream of a certain directionality may be …\nData flows in both directions\nSend would block\nNo more data is currently available on this stream.\nThe peer is not able to accept additional data, or the …\nA source of one or more buffers which can be converted …\nthe number of connection IDs provided by the peer exceeds …\nthe server refused to accept a new connection\nreceived more data in CRYPTO frames than can be buffered\nThe CE codepoint, signalling that congestion was …\nA chunk of data from the receive stream\nChunks returned from <code>RecvStream::read()</code>.\nThe connection could not be created because not enough of …\nThe connection could not be created because not enough of …\nThe initiator of a connection\nConfiguration for outgoing connections\nError indicating that a stream has not been opened or has …\nThe stream has not been opened or was already stopped, …\nThe stream has not been opened or has already been …\nThe stream has not been opened or was already finished or …\nErrors in the configuration of an endpoint\nErrors in the parameters being used to create a new …\nThe connection was successfully established\nProtocol state and logic for a single QUIC connection\nReason given by the transport for closing the connection\nThe peer’s QUIC stack aborted the connection …\nReasons why a connection might be lost\nEvents sent from an Endpoint to a Connection\nThe datagram is redirected to its <code>Connection</code>\nInternal identifier for a <code>Connection</code> currently associated …\nProtocol-level identifier for a connection.\nGenerates connection IDs for incoming connections\nParse connection id in short header packet\nThe connection was lost\nConnection statistics\nThe QUIC protocol version implemented.\nAn unreliable datagram\nEvent resulting from processing a single datagram\nOne or more application datagrams have been received\nAPI to control datagram traffic\nOne or more application datagrams have been sent after …\nWhether a stream communicates data in both directions or …\nDatagram support is disabled locally\nExplicit congestion notification codepoint\nThe ECT(0) codepoint, indicating that an endpoint is …\nThe ECT(1) codepoint, indicating that an endpoint is …\nThe main entry point to the library\nGlobal configuration for the endpoint, affecting all …\nEvents sent from a Connection to an Endpoint\nThe endpoint can no longer create new connections\nEvents of interest to the application\nreceived a STREAM frame or a RESET_STREAM frame containing …\nreceived more data than permitted in advertised data limits\nreceived a frame that was badly formatted\nReasons why attempting to finish a stream might fail\nA finished stream has been fully acknowledged or stopped\nA <code>ConnectionIdParser</code> implementation that assumes the …\nNumber of frames transmitted of each frame type\nA QUIC frame type\nHandshake packet\nThe connection’s handshake data is ready\nGenerates 8-byte connection IDs that can be efficiently …\nthe endpoint encountered an internal error and cannot …\nreceived an invalid Retry Token in a client Initial\nMaximum duration of inactivity to accept before timing out …\nAttempted an ordered read following an unordered read\nAn incoming connection for which the server has not yet …\nAn Initial packet header\nThe connection ID was not recognized by the …\nThe packet header is invalid\nThe remote <code>SocketAddr</code> supplied was malformed\nThe given server name was malformed\nkey update error\nThe local application closed the connection\nA Long packet header, as used during the handshake\nLong packet types with uniform header structure\nThe largest representable value\nThe largest encoded value length\nParameters governing MTU discovery.\nthe connection is being closed abruptly in the absence of …\nno viable network path exists\nThe datagram may result in starting a new <code>Connection</code>\nNo default client configuration was set up\nNull implementation of <code>TokenLog</code>, which never accepts tokens\nNull implementation of <code>TokenStore</code>, which does not store …\nReceived an observation of our external address from the …\nOne or more new streams has been opened and might be …\nValue exceeds supported bounds\ndetected an error with protocol compliance that was not …\nPacket decode error\nDecodes a QUIC packet’s invariant header\nStatistics related to a transmission path\nPlain packet header\nHeader of an Initial packet, before decryption\nGenerates purely random connection IDs of a specified …\nErrors triggered when reading from a recv stream\nA currently open stream likely has data or errors waiting …\nErrors triggered when opening a recv stream for reading\nAccess to streams\nThe peer abandoned transmitting data on this stream.\nThe peer is unable to continue processing this connection, …\nResponse generated directly by the endpoint\nA Retry packet header\nError for attempting to retry an <code>Incoming</code> which already …\nRTT estimation for a particular network path\nreceived a frame for a stream identifier that exceeded …\nreceived a frame for a stream that was not in a state that …\nErrors that can arise when sending a datagram\nAccess to streams\nThe acceptor of a connection\nParameters governing incoming connections\nA short packet header, as used during the data phase\nIndicates whether a frame needs to be transmitted\nWhether an endpoint was the initiator of a connection\nDefault implementation of <code>TimeSource</code>\nThe peer is no longer accepting data on this stream, and …\nThe peer is no longer accepting data on this stream. No …\nThe peer asked us to stop sending on an outgoing stream\nStream events\nApplication events about streams\nIdentifier for a stream within a particular connection\nAccess to streams\nreceived transport parameters that were badly formatted, …\nObject to get current <code>SystemTime</code>\nCommunication with the peer has lapsed for longer than the …\nResponsible for limiting clients’ ability to reuse …\nError for when a validation token may have been reused\nResponsible for storing validation tokens received from …\nThe datagram is larger than the connection can currently …\nAn outgoing packet\nParameters governing the core QUIC state machine\nTransport-level errors occur when a peer violates the …\nThe peer violated the QUIC specification as understood by …\nTransport-level error code\nStatistics about UDP datagrams transmitted or received on …\nData flows only from the stream’s initiator\nThe peer does not support receiving datagram frames\nThe local endpoint does not support the QUIC version …\nPacket uses a QUIC version that is not supported\nConfiguration for sending and handling validation tokens …\nAn integer less than 2^62\nError returned when constructing a <code>VarInt</code> from a value &gt;= …\nThe peer doesn’t implement any supported version\nA Version Negotiation packet header\nA formerly write-blocked stream might be ready for a write …\nErrors triggered while writing to a send stream\nIndicates how many bytes and chunks had been transferred …\n0-RTT packet\nAccept a remotely initiated stream of a certain …\nAttempt to accept this incoming connection (an error may …\nFor clients, if the peer accepted the 0-RTT data packets\nThe ack-eliciting threshold we will request the peer to use\nSpecifies the ACK frequency config (see <code>AckFrequencyConfig</code> …\nWhether the implementation is permitted to set the spin …\nSpecifies the amount of time that MTU discovery should …\nThe number of times a black hole was detected in the path\nThe contents of the chunk\nThe total amount of bytes which have been transferred …\nThe amount of bytes which had been written\nUnderlying error describing reason for failure\nRecord that the token was used and, ideally, return a …\nThe amount of full chunks which had been written\nSupply a custom connection ID generator factory\nReturns the length of a CID for connections created by …\nProvide the length of dst_cid in short header packet\nReturns the lifetime of generated Connection IDs\nClose a connection immediately\nType of error\nCoding related traits.\nAccess the configuration used by this endpoint\nLogic for controlling the rate at which data is sent\nHow to construct new <code>congestion::Controller</code>s\nCongestion events on the connection\nCurrent state of this connection’s congestion …\nInitiate a connection\nConservative estimate of RTT\nTraits and implementations for the QUIC cryptography …\nCreate QUIC error code from TLS alert code\nTLS configuration used for incoming connections\nMaximum quantity of out-of-order crypto layer data to …\nGet a session reference\nStorage size required for the largest packet known to be …\nLargest UDP payload size the path currently supports\nCurrent congestion window of the connection\nPayload\nMaximum number of incoming application datagram bytes to …\nMaximum number of outgoing application datagram bytes to …\nControl datagrams\nThe amount of UDP datagrams observed\nDecode a plain header from given buffer, with given …\nThe socket this datagram should be sent to\nWhich directions data flows in\nConstruct an event that indicating that a <code>Connection</code> will …\nThe destination connection ID of the packet\nThe destination Connection ID of the packet\nDestination Connection ID\nExplicit congestion notification bits to set on the packet\nWhether to use “Generic Segmentation Offload” to …\nClass of error as encoded in the specification\nApplication-specific reason code\nMark the read data as consumed from the stream.\nFinish a send stream, signalling that no more data will be …\nUpdate traffic keys spontaneously\nFrame type that triggered the error\nStatistics about frames received on a connection\nStatistics about frames transmitted on a connection\nType of frame that caused the close\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new object from the given bits\nConstructs cid by reading <code>len</code> bytes from a <code>Buf</code>\nCreate a generator with a specific key\nConstruct a <code>VarInt</code> infallibly\nSucceeds iff <code>x</code> &lt; 2^62\nCreate a VarInt without ensuring it’s in range\nGenerates a new CID\nThe current best RTT estimation.\nGet the current value of <code>max_udp_payload_size</code>\nWhether to accept QUIC packets containing any value for …\nProcess an incoming UDP datagram\nProcess <code>ConnectionEvent</code>s generated by the associated …\nProcess <code>EndpointEvent</code>s emitted from related <code>Connection</code>s\nProcess timer expirations\nWhether 0-RTT is/was possible during the handshake\nWhether there are any pending retransmits\nIgnore this incoming connection attempt, not sending any …\nCounter for the number of bytes currently used in the …\nMaximum number of received bytes to buffer for each …\nMaximum number of received bytes to buffer for all <code>Incoming</code>\nDistinguishes streams of the same initiator and …\nConfigure how to populate the destination CID of the …\nThe initial value to be used as the maximum UDP payload …\nThe RTT used before an RTT sample is taken\nWhich side of a connection initiated the stream\nPotentially store a token for later one-time use\nSpecifies the time to wait after completing MTU discovery …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the <code>Incoming</code>\nExtract the integer value\nThe amount of I/O operations executed\nReturns whether the codepoint is a CE, signalling that …\nShorthand for <code>self == Side::Client</code>\nWhether the connection is closed\nWhether there is no longer any need to keep the connection …\nDetermine whether this is the last event a <code>Connection</code> will …\nWhether the connection is in the process of being …\nShorthand for <code>self == Side::Server</code>\nPeriod of inactivity before sending a keep-alive packet\nLength of QUIC packet being decoded\nLength of the packet payload\nDuration after an address validation token was issued for …\nHandle a change in the local address, i.e. an active …\nThe local IP address which was used when the peer …\nThe local IP address which was used when the peer …\nSet a custom <code>TokenLog</code>\nThe amount of bytes lost on this path\nThe amount of packets lost on this path\nThe amount of PLPMTUD probe packets lost on this path …\nThe <code>max_ack_delay</code> we will request the peer to use\nMaximum number of incoming bidirectional streams that may …\nCurrent number of remotely initiated streams that may be …\nVariant of <code>max_concurrent_bidi_streams</code> affecting …\nMaximum duration of inactivity to accept before timing out …\nMaximum number of <code>Incoming</code> to allow to exist at a time\nCompute the maximum size of datagrams that may passed to …\nMaximum UDP payload size accepted from peers (excluding …\nWhether it is legal to respond with a retry packet\nWhether to allow clients to migrate to new addresses\nMinimum RTT registered so far for this estimator.\nThe maximum UDP payload size guaranteed to be supported by …\nMinimum interval between outgoing stateless reset packets\nSpecifies the minimum MTU change to stop the MTU discovery …\nSpecifies the MTU discovery config (see <code>MtuDiscoveryConfig</code> …\nCreate a new endpoint\nCreate a new instance of <code>FixedLengthConnectionIdParser</code>\nCreate a generator with a random key\nCreate a default config with a particular <code>reset_key</code>\nCreate a default config with a particular handshake token …\nCreate a default config with a particular cryptographic …\nBegin decoding a QUIC packet from <code>bytes</code>, returning any …\nConstruct cid from byte array\nInitialize Random CID generator with a fixed CID length\nCreate a new StreamId\nNext\nGet <code>SystemTime::now()</code> or the mocked equivalent\nThe offset in the stream\nOpen a single stream if possible\nNumber of connections that are currently open\nThe original destination connection ID sent by the client\nMaximum reordering in packet number space before FACK …\nParse a connection id from given buffer\nStatistics related to the current transmission path\nResets path-specific settings.\nNumber of consecutive PTOs after which network is …\nPing the remote endpoint\nReturns application-facing events\nReturn endpoint-facing events\nReturns the next time at which <code>handle_timeout</code> should be …\nReturns packets to transmit\nReturns the next chunk from the source of owned chunks.\nThe preferred IPv4 address that will be communicated to …\nThe preferred IPv6 address that will be communicated to …\nGet the priority of a stream\nRead from the given recv stream\nHuman-readable reason for the close\nHuman-readable reason for the close\nHuman-readable explanation of the reason\nWhether to receive observed address reports from other …\nMaximum number of bytes the peer may transmit across all …\nCheck whether this stream has been reset by the peer, …\nReceive an unreliable, unordered datagram\nProvide control over streams\nReject this incoming connection attempt\nThe latest socket address for this connection’s peer\nThe peer’s UDP address\nWhether the socket address that is initiating this …\nThe number of remotely initiated open streams of a certain …\nThe reordering threshold we will request the peer to use\nAbandon transmitting data on a stream\nPrivate key used to send authenticated connection resets …\nOptional response to transmit back\nRespond with a retry packet, requiring the client to retry …\nDuration after a retry token was issued for which it’s …\nOptional seed to be used internally for random number …\nCurrent best estimate of this connection’s latency …\nCurrent best estimate of this connection’s latency …\nSaturating integer addition. Computes self + rhs, …\nThe segment size if this transmission contains multiple …\nQueue an unreliable, unordered datagram for immediate …\nBytes available in the outgoing datagram buffer\nWhether to implement fair queuing for send streams having …\nWhether to send observed address reports to peers.\nProvide control over streams\nThe number of streams that may have unacknowledged data.\nMaximum number of bytes to transmit to a peer without …\nNumber of address validation tokens sent to a client when …\nThe amount of packets sent on this path\nThe amount of PLPMTUD probe packets sent on this path …\nSet the lifetime of CIDs created by this generator\nSet the lifetime of CIDs created by this generator\nModify the number of remotely initiated streams that may …\nSet the priority of a stream\nSee <code>TransportConfig::receive_window()</code>\nReplace the server configuration, affecting new incoming …\nReturns whether a frame should be transmitted\nLook up whether we’re the client or server of this …\nAmount of data written to the caller-supplied buffer\nSource Connection ID\nOptional source IP address for the datagram\nReturns connection statistics\nStop accepting data on the given receive stream\nCheck if this stream was stopped, get the reason if it was\nMaximum number of bytes the peer may transmit without …\nProvide control over streams\nOverride supported QUIC versions\nTry to find and take a token that was stored with the …\nObject to get current <code>SystemTime</code>\nMaximum reordering in time space before time based loss …\nPrivate key used to authenticate data included in …\nThe position of a token in the packet buffer\nSet a custom <code>TokenStore</code>\nTransport configuration to use for incoming connections\nSet a custom <code>TransportConfig</code>\nSet a custom <code>TransportConfig</code>\nQUIC connection transport parameters\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nStatistics about UDP datagrams received on a connection\nStatistics about UDP datagrams transmitted on a connection\nSpecifies the upper bound to the max UDP payload size that …\nQuickly determine whether <code>cid</code> could have been generated by …\nQuickly determine whether <code>cid</code> could have been generated by …\nConfiguration for sending and handling validation tokens\nSet a custom <code>ValidationTokenConfig</code>\nSet the QUIC version to use\nQUIC version\nCreate a server config with the given <code>crypto::ServerConfig</code>\nCreate a client configuration that trusts specified trust …\nCreate a server config with the given certificate chain to …\nSend data on the given stream\nSend data on the given stream\nReason that the connection was closed\nDestination Connection ID\nSource Connection ID\nThe version that was unsupported\nDestination Connection ID\nDestination Connection ID\nDestination Connection ID\nDestination Connection ID\nLength of the packet payload\nRandom value\nSpin bit\nSource Connection ID\nSource Connection ID\nSource Connection ID\nType of the Long header packet\nQUIC version\nQUIC version\nDirectionality for which streams have been opened\nDirectionality for which streams are newly available\nError code supplied by the peer\nWhich stream is now readable\nWhich stream is now writable\nWhich stream has been finished\nWhich stream has been stopped\nInfallible encoding and decoding of QUIC primitives\nContains the error value\nContains the success value\nCoding result type\nError indicating that the provided buffer was too small\nDecode a <code>Self</code> from the provided buffer, if the buffer is …\nAppend the encoding of <code>self</code> to the provided buffer\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExperimental! Use at your own risk.\nConfiguration for the <code>Bbr</code> congestion controller\nCommon interface for different congestion controllers\nConstructs controllers on demand\nThe RFC8312 congestion controller, as widely used for TCP\nConfiguration for the <code>Cubic</code> congestion controller\nA simple, standard congestion controller\nConfiguration for the <code>NewReno</code> congestion controller\nConstruct a fresh <code>Controller</code>\nDuplicate the controller’s state\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitial congestion window\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns Self for use in down-casting to extract …\nReduction in congestion window when a new loss event is …\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nPacket deliveries were confirmed\nPackets were deemed lost or marked congested\nPackets are acked in batches, all with the same <code>now</code> …\nThe known MTU for the current network path has been updated\nOne or more packets were just sent\nNumber of ack-eliciting bytes that may be in flight\nA key for sealing data with AEAD-based algorithms\nClient-side configuration for the crypto protocol\nGeneric crypto errors\nError returned by Session::export_keying_material.\nA pseudo random key for HKDF\nKeys used to protect packet headers\nA key for signing with HMAC-based algorithms\nA pair of keys for bidirectional communication\nA complete set of keys for a certain packet space\nKeys used to protect packet payloads\nServer-side configuration for the crypto protocol\nA cryptographic session (commonly TLS)\nError indicating that the specified QUIC version is not …\nDerive AEAD using hkdf\nMaximum number of packets that may be sent using a single …\nDecrypt the packet payload with the given packet number\nDecrypt the given packet’s header\nGet the 0-RTT keys if available (clients only)\nIf the 0-RTT-encrypted data has been accepted by the peer\nEncrypt the packet payload with the given packet number\nEncrypt the given packet’s header\nFill <code>output</code> with <code>output.len()</code> bytes of keying material …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet data negotiated during the handshake, if available\nHeader protection keys\nCreate the initial set of keys given the client’s …\nCreate the initial set of keys given the client’s …\nMaximum number of incoming packets that may fail …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> until the connection is fully established.\nVerify the integrity of a retry packet\nKey for encrypting data\nCompute keys for the next key update\nMethod for opening a sealed message <code>data</code>\nPacket protection keys\nGet the peer’s identity, if available\nRead bytes of handshake data\nKey for decrypting data\nGenerate the integrity tag for a retry packet\nTLS interface based on rustls\nThe sample size used for this key’s algorithm\nMethod for sealing message <code>data</code>\nMethod for signing a message\nLength of <code>sign</code>’s output\nStart a client session with this configuration\nStart a server session with this configuration\nThe length of the AEAD tag appended to packets on …\nThe peer’s QUIC transport parameters\nMethod for verifying a message\nWrites handshake bytes into the given buffer and …\nWe received a fatal alert.  This means the peer is unhappy.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nWe couldn’t decrypt a message.  This is invariably fatal.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nAuthentication data for (rustls) TLS session\nThis function doesn’t work until the TLS handshake is …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nSpecific failure cases from <code>keys_match</code> or a …\nA provided certificate revocation list (CRL) was invalid.\nWe saw an invalid certificate.\nAn error occurred while handling Encrypted Client Hello …\nThe peer sent us a TLS message with invalid contents.\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nThe initial cipher suite (AES-128-GCM-SHA256) is not …\nAny other error.\nThe peer doesn’t support a protocol version/feature we …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nA QUIC-compatible TLS client configuration\nA QUIC-compatible TLS server configuration\nA rustls TLS session\nThe certificate verifier doesn’t support the given type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFor the rustls <code>TlsSession</code>, the <code>Any</code> type is …\nThe negotiated application protocol, if ALPN is in use\nThe server name specified by the client, if any\nInitialize a QUIC-compatible TLS client configuration with …\nInitialize a QUIC-compatible TLS client configuration with …\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received\nErrors encountered while decoding <code>TransportParameters</code>\nParameters that are semantically invalid\nCatch-all error for problems while decoding transport …\nTransport parameters used to negotiate connection-level …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecode <code>TransportParameters</code> from buffer\nEncode <code>TransportParameters</code> into buffer")