searchState.loadedDescShard("iroh_quinn", 0, "QUIC transport protocol implementation\nthe endpoint has reached the confidentiality or integrity …\nthe application or application protocol caused the …\nFuture produced by <code>Endpoint::accept</code>\nFuture produced by <code>Connection::accept_bi</code>\nFuture produced by <code>Connection::accept_uni</code>\nParameters for controlling the peer’s acknowledgement …\nReason given by an application for closing the connection\nThe peer closed the connection\nAbstract implementation of an async timer for runtime …\nAbstract implementation of a UDP socket for runtime …\nData flows in both directions\nthe number of connection IDs provided by the peer exceeds …\nthe server refused to accept a new connection\nreceived more data in CRYPTO frames than can be buffered\nThe CE codepoint, signalling that congestion was …\nA chunk of data from the receive stream\nThe connection could not be created because not enough of …\nThe connection could not be created because not enough of …\nThe initiator of a connection\nConfiguration for outgoing connections\nError indicating that a stream has not been opened or has …\nThe stream has already been stopped, finished, or reset\nThe stream has already been finished or reset\nErrors in the configuration of an endpoint\nErrors in the parameters being used to create a new …\nIn-progress connection attempt future\nA QUIC connection.\nReason given by the transport for closing the connection\nThe peer’s QUIC stack aborted the connection …\nReasons why a connection might be lost\nProtocol-level identifier for a connection.\nGenerates connection IDs for incoming connections\nThe connection was lost\nThe connection was lost\nThe connection was lost\nThe connection was lost\nThe connection was lost\nConnection statistics\nWhether a stream communicates data in both directions or …\nDatagram support is disabled locally\nExplicit congestion notification codepoint\nThe ECT(0) codepoint, indicating that an endpoint is …\nThe ECT(1) codepoint, indicating that an endpoint is …\nA QUIC endpoint.\nGlobal configuration for the endpoint, affecting all …\nStatistics on Endpoint activity\nThe endpoint can no longer create new connections\nreceived a STREAM frame or a RESET_STREAM frame containing …\nreceived more data than permitted in advertised data limits\nreceived a frame that was badly formatted\nThe stream finished before all bytes were read\nNumber of frames transmitted of each frame type\nA QUIC frame type\nthe endpoint encountered an internal error and cannot …\nreceived an invalid Retry Token in a client Initial\nMaximum duration of inactivity to accept before timing out …\nAttempted an ordered read following an unordered read\nAn incoming connection for which the server has not yet …\nBasic adapter to let <code>Incoming</code> be <code>await</code>-ed like a <code>Connecting</code>\nThe remote <code>SocketAddr</code> supplied was malformed\nThe given server name was malformed\nkey update error\nThe local application closed the connection\nThe largest representable value\nThe largest encoded value length\nParameters governing MTU discovery.\nthe connection is being closed abruptly in the absence of …\nno viable network path exists\nNo default client configuration was set up\nNull implementation of <code>TokenLog</code>, which never accepts tokens\nNull implementation of <code>TokenStore</code>, which does not store …\nFuture produced by <code>Connection::open_bi</code>\nFuture produced by <code>Connection::open_uni</code>\nValue exceeds supported bounds\ndetected an error with protocol compliance that was not …\nStatistics related to a transmission path\nAn error occurred during reading\nFuture produced by <code>Connection::read_datagram</code>\nErrors that arise from reading from a stream.\nA read error occurred\nErrors that arise from reading from a stream.\nErrors from <code>RecvStream::read_to_end</code>\nA stream that can only be used to receive data\nThe peer abandoned transmitting data on this stream\nThe peer is unable to continue processing this connection, …\nErrors that arise while waiting for a stream to be reset\nError for attempting to retry an <code>Incoming</code> which already …\nAbstracts I/O and timer operations for runtime independence\nreceived a frame for a stream identifier that exceeded …\nreceived a frame for a stream that was not in a state that …\nFuture produced by <code>Connection::send_datagram_wait</code>\nErrors that can arise when sending a datagram\nA stream that can only be used to send data\nThe acceptor of a connection\nParameters governing incoming connections\nWhether an endpoint was the initiator of a connection\nDefault implementation of <code>TimeSource</code>\nThe peer is no longer accepting data on this stream\nErrors that arise while monitoring for a send stream stop …\nIdentifier for a stream within a particular connection\nreceived transport parameters that were badly formatted, …\nObject to get current <code>SystemTime</code>\nCommunication with the peer has lapsed for longer than the …\nResponsible for limiting clients’ ability to reuse …\nError for when a validation token may have been reused\nResponsible for storing validation tokens received from …\nA Quinn runtime for Tokio\nThe datagram is larger than the connection can currently …\nThe stream is larger than the user-supplied limit\nAn outgoing packet\nParameters governing the core QUIC state machine\nThe peer violated the QUIC specification as understood by …\nTransport-level error code\nAn object for asynchronously writing to an associated …\nA helper for constructing <code>UdpSender</code>s from an underlying …\nParts of the <code>UdpSender</code> trait that aren’t asynchronous or …\nStatistics about UDP datagrams transmitted or received on …\nData flows only from the stream’s initiator\nThe peer does not support receiving datagram frames\nThe local endpoint does not support the QUIC version …\nConfiguration for sending and handling validation tokens …\nAn integer less than 2^62\nError returned when constructing a <code>VarInt</code> from a value &gt;= …\nThe peer doesn’t implement any supported version\nA handle to some connection internals, use with care.\nErrors that arise from writing to a stream\nIndicates how many bytes and chunks had been transferred …\nFuture that completes when a connection is fully …\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nGet the next incoming connection attempt from a client\nAttempt to accept this incoming connection (an error may …\nAccept the next incoming bidirectional stream\nAccept the next incoming uni-directional stream\nAccept this incoming connection using a custom …\nCummulative number of Quic handshakes accepted by this …\nThe ack-eliciting threshold we will request the peer to use\nSpecifies the ACK frequency config (see <code>AckFrequencyConfig</code> …\nWhether the implementation is permitted to set the spin …\nSpecifies the amount of time that MTU discovery should …\nThe number of times a black hole was detected in the path\nThe contents of the chunk\nThe total amount of bytes which have been transferred …\nThe amount of bytes which had been written\nRecord that the token was used and, ideally, return a …\nThe amount of full chunks which had been written\nSupply a custom connection ID generator factory\nReturns the length of a CID for connections created by …\nReturns the lifetime of generated Connection IDs\nHelper to construct an endpoint for use with outgoing …\nClose the connection immediately.\nClose all of this endpoint’s connections immediately and …\nIf the connection is closed, the reason why.\nWait for the connection to be closed for any reason\nLogic for controlling the rate at which data is sent\nHow to construct new <code>congestion::Controller</code>s\nCongestion events on the connection\nCurrent state of the congestion control algorithm, for …\nConnect to a remote endpoint\nConnect to a remote endpoint using a custom configuration.\nCreate a <code>UdpSender</code> that can register a single task for …\nTraits and implementations for the QUIC cryptography …\nCreate QUIC error code from TLS alert code\nTLS configuration used for incoming connections\nMaximum quantity of out-of-order crypto layer data to …\nLargest UDP payload size the path currently supports\nCurrent congestion window of the connection\nMaximum number of incoming application datagram bytes to …\nMaximum number of outgoing application datagram bytes to …\nBytes available in the outgoing datagram buffer\nThe amount of UDP datagrams observed\nAutomatically select an appropriate runtime from those …\nThe socket this datagram should be sent to\nWhich directions data flows in\nExplicit congestion notification bits to set on the packet\nWhether to use “Generic Segmentation Offload” to …\nClass of error as encoded in the specification\nApplication-specific reason code\nDerive keying material from this connection’s TLS …\nNotify the peer that no more data will ever be written to …\nUpdate traffic keys spontaneously\nStatistics about frames received on a connection\nStatistics about frames transmitted on a connection\nType of frame that caused the close\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate new object from the given bits\nConstructs cid by reading <code>len</code> bytes from a <code>Buf</code>\nConstruct a <code>VarInt</code> infallibly\nSucceeds iff <code>x</code> &lt; 2^62\nCreate a VarInt without ensuring it’s in range\nGenerates a new CID\nGet the current value of <code>max_udp_payload_size</code>\nWhether to accept QUIC packets containing any value for …\nParameters negotiated during the handshake\nParameters negotiated during the handshake\nGet the identity of this stream\nGet the identity of this stream\nIgnore this incoming connection attempt, not sending any …\nCummulative number of Quic handshakes ignored on this …\nMaximum number of received bytes to buffer for each …\nMaximum number of received bytes to buffer for all <code>Incoming</code>\nDistinguishes streams of the same initiator and …\nConfigure how to populate the destination CID of the …\nThe initial value to be used as the maximum UDP payload …\nThe RTT used before an RTT sample is taken\nWhich side of a connection initiated the stream\nPotentially store a token for later one-time use\nSpecifies the time to wait after completing MTU discovery …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a 0-RTT or 0.5-RTT connection at the cost of …\nGet the <code>Incoming</code>\nExtract the integer value\nThe amount of I/O operations executed\nCheck if this stream has been opened during 0-RTT.\nReturns <code>true</code> if the <code>Connection</code> associated with this handle …\nReturns whether the codepoint is a CE, signalling that …\nShorthand for <code>self == Side::Client</code>\nShorthand for <code>self == Side::Server</code>\nPeriod of inactivity before sending a keep-alive packet\nDuration after an address validation token was issued for …\nLook up the local IP address and port used by this socket\nGet the local <code>SocketAddr</code> the underlying socket is bound to\nThe local IP address which was used when the peer …\nThe local IP address which was used when the peer …\nThe local IP address which was used when the peer …\nSet a custom <code>TokenLog</code>\nThe amount of bytes lost on this path\nThe amount of packets lost on this path\nThe amount of PLPMTUD probe packets lost on this path …\nThe <code>max_ack_delay</code> we will request the peer to use\nMaximum number of incoming bidirectional streams that may …\nVariant of <code>max_concurrent_bidi_streams</code> affecting …\nCompute the maximum size of datagrams that may be passed …\nMaximum duration of inactivity to accept before timing out …\nMaximum number of <code>Incoming</code> to allow to exist at a time\nMaximum number of datagrams that might be described by a …\nMaximum number of datagrams that might be described by a …\nSee <code>UdpSender::max_transmit_segments</code>.\nMaximum number of datagrams that a <code>Transmit</code> may encode.\nMaximum number of datagrams that a <code>Transmit</code> may encode.\nMaximum UDP payload size accepted from peers (excluding …\nWhether datagrams might get fragmented into multiple parts\nWhether datagrams might get fragmented into multiple parts\nWhether it is legal to respond with a retry packet\nWhether to allow clients to migrate to new addresses\nThe maximum UDP payload size guaranteed to be supported by …\nMinimum interval between outgoing stateless reset packets\nSpecifies the minimum MTU change to stop the MTU discovery …\nSpecifies the MTU discovery config (see <code>MtuDiscoveryConfig</code> …\nResets path-specific state.\nConstruct an endpoint with arbitrary configuration and …\nCreate helper that implements <code>UdpSender</code> from a socket.\nCreate a default config with a particular <code>reset_key</code>\nCreate a default config with a particular handshake token …\nCreate a default config with a particular cryptographic …\nConstruct cid from byte array\nCreate a new StreamId\nConstruct a timer that will expire at <code>i</code>\nConstruct an endpoint with arbitrary configuration and …\nGet <code>SystemTime::now()</code> or the mocked equivalent\nLook up the current time\nLook up the current time\nTrack changed on our external address as reported by the …\nThe offset in the stream\nInitiate a new outgoing bidirectional stream.\nGet the number of connections that are currently open\nInitiate a new outgoing unidirectional stream.\nThe original destination CID when initiating the connection\nCummulative number of Quic handshakees sent from this …\nMaximum reordering in packet number space before FACK …\nStatistics related to the current transmission path\nCryptographic identity of the peer\nNumber of consecutive PTOs after which network is …\nCheck whether the timer has expired, and register to be …\nAttempts to read from the stream into buf.\nReceive UDP datagrams, or register to be woken if …\nSend a UDP datagram, or register to be woken if sending …\nAttempt to write bytes from buf into the stream.\nThe preferred IPv4 address that will be communicated to …\nThe preferred IPv6 address that will be communicated to …\nGet the priority of the send stream\nRead data contiguously from the stream.\nRead the next segment of data\nRead the next segments of data\nReceive an application datagram\nRead an exact number of bytes contiguously from the stream.\nConvenience method to read all remaining data into a buffer\nHuman-readable reason for the close\nHuman-readable reason for the close\nSwitch to a new UDP socket\nSwitch to a new UDP socket\nWhether to receive observed address reports from other …\nMaximum number of bytes the peer may transmit across all …\nCompletes when the stream has been reset by the peer or …\nReject this incoming connection attempt\nCummulative number of Quic handshakes refused on this …\nThe peer’s UDP address\nThe peer’s UDP address\nThe peer’s UDP address\nWhether the socket address that is initiating this …\nThe reordering threshold we will request the peer to use\nUpdate the timer to expire at <code>i</code>\nClose the send stream immediately.\nPrivate key used to send authenticated connection resets …\nRespond with a retry packet, requiring the client to retry …\nDuration after a retry token was issued for which it’s …\nOptional seed to be used internally for random number …\nCurrent best estimate of this connection’s latency …\nCurrent best estimate of this connection’s latency …\nSaturating integer addition. Computes self + rhs, …\nThe segment size if this transmission contains multiple …\nTransmit <code>data</code> as an unreliable, unordered application …\nTransmit <code>data</code> as an unreliable, unordered application …\nWhether to implement fair queuing for send streams having …\nWhether to send observed address reports to peers.\nMaximum number of bytes to transmit to a peer without …\nNumber of address validation tokens sent to a client when …\nThe amount of packets sent on this path\nThe amount of PLPMTUD probe packets sent on this path …\nHelper to construct an endpoint for use with both incoming …\nSet the client configuration used by <code>connect</code>\nModify the number of remotely initiated bidirectional …\nModify the number of remotely initiated unidirectional …\nSet the priority of the send stream\nSee <code>proto::TransportConfig::receive_window()</code>\nReplace the server configuration, affecting new incoming …\nAmount of data written to the caller-supplied buffer\nDrive <code>future</code> to completion in the background\nOptional source IP address for the datagram\nA stable identifier for this connection\nReturns connection statistics\nReturns relevant stats from this Endpoint\nStop accepting data\nCompletes when the peer stops the stream or reads the …\nMaximum number of bytes the peer may transmit without …\nOverride supported QUIC versions\nTry to find and take a token that was stored with the …\nObject to get current <code>SystemTime</code>\nMaximum reordering in time space before time based loss …\nPrivate key used to authenticate data included in …\nSet a custom <code>TokenStore</code>\nTransport configuration to use for incoming connections\nSet a custom <code>TransportConfig</code>\nSet a custom <code>TransportConfig</code>\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nTry to send a UDP datagram, if the socket happens to be …\nTry to send a transmit, if the socket happens to be …\nStatistics about UDP datagrams received on a connection\nStatistics about UDP datagrams transmitted on a connection\nSpecifies the upper bound to the max UDP payload size that …\nQuickly determine whether <code>cid</code> could have been generated by …\nConfiguration for sending and handling validation tokens\nSet a custom <code>ValidationTokenConfig</code>\nSet the QUIC version to use\nWait for all connections on the endpoint to be cleanly …\nReturns a weak reference to the inner connection struct.\nCreate a server config with the given <code>crypto::ServerConfig</code>\nCreate a client configuration that trusts specified trust …\nCreate a server config with the given certificate chain to …\nConvert <code>t</code> into the socket type used by this runtime\nWrite bytes to the stream\nConvenience method to write an entire buffer to the stream\nConvenience method to write an entire list of chunks to …\nConvenience method to write a single chunk in its entirety …\nWrite chunks to the stream\nExperimental! Use at your own risk.\nConfiguration for the <code>Bbr</code> congestion controller\nCommon interface for different congestion controllers\nConstructs controllers on demand\nThe RFC8312 congestion controller, as widely used for TCP\nConfiguration for the <code>Cubic</code> congestion controller\nA simple, standard congestion controller\nConfiguration for the <code>NewReno</code> congestion controller\nConstruct a fresh <code>Controller</code>\nDuplicate the controller’s state\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitial congestion window\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nDefault limit on the amount of outstanding data in bytes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns Self for use in down-casting to extract …\nReduction in congestion window when a new loss event is …\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nConstruct a state using the given <code>config</code> and current time …\nPacket deliveries were confirmed\nPackets were deemed lost or marked congested\nPackets are acked in batches, all with the same <code>now</code> …\nThe known MTU for the current network path has been updated\nOne or more packets were just sent\nNumber of ack-eliciting bytes that may be in flight\nA key for sealing data with AEAD-based algorithms\nClient-side configuration for the crypto protocol\nGeneric crypto errors\nError returned by Session::export_keying_material.\nA pseudo random key for HKDF\nKeys used to protect packet headers\nA key for signing with HMAC-based algorithms\nA pair of keys for bidirectional communication\nA complete set of keys for a certain packet space\nKeys used to protect packet payloads\nServer-side configuration for the crypto protocol\nA cryptographic session (commonly TLS)\nError indicating that the specified QUIC version is not …\nDerive AEAD using hkdf\nMaximum number of packets that may be sent using a single …\nDecrypt the packet payload with the given packet number\nDecrypt the given packet’s header\nGet the 0-RTT keys if available (clients only)\nIf the 0-RTT-encrypted data has been accepted by the peer\nEncrypt the packet payload with the given packet number\nEncrypt the given packet’s header\nFill <code>output</code> with <code>output.len()</code> bytes of keying material …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet data negotiated during the handshake, if available\nHeader protection keys\nCreate the initial set of keys given the client’s …\nCreate the initial set of keys given the client’s …\nMaximum number of incoming packets that may fail …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> until the connection is fully established.\nVerify the integrity of a retry packet\nKey for encrypting data\nCompute keys for the next key update\nMethod for opening a sealed message <code>data</code>\nPacket protection keys\nGet the peer’s identity, if available\nRead bytes of handshake data\nKey for decrypting data\nGenerate the integrity tag for a retry packet\nTLS interface based on rustls\nThe sample size used for this key’s algorithm\nMethod for sealing message <code>data</code>\nMethod for signing a message\nLength of <code>sign</code>’s output\nStart a client session with this configuration\nStart a server session with this configuration\nThe length of the AEAD tag appended to packets on …\nThe peer’s QUIC transport parameters\nMethod for verifying a message\nWrites handshake bytes into the given buffer and …\nWe received a fatal alert.  This means the peer is unhappy.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nWe couldn’t decrypt a message.  This is invariably fatal.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nAuthentication data for (rustls) TLS session\nThis function doesn’t work until the TLS handshake is …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nSpecific failure cases from <code>keys_match</code> or a …\nA provided certificate revocation list (CRL) was invalid.\nWe saw an invalid certificate.\nAn error occurred while handling Encrypted Client Hello …\nThe peer sent us a TLS message with invalid contents.\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nThe initial cipher suite (AES-128-GCM-SHA256) is not …\nAny other error.\nThe peer doesn’t support a protocol version/feature we …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nA QUIC-compatible TLS client configuration\nA QUIC-compatible TLS server configuration\nA rustls TLS session\nThe certificate verifier doesn’t support the given type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFor the rustls <code>TlsSession</code>, the <code>Any</code> type is …\nThe negotiated application protocol, if ALPN is in use\nThe server name specified by the client, if any\nInitialize a QUIC-compatible TLS client configuration with …\nInitialize a QUIC-compatible TLS client configuration with …\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received")