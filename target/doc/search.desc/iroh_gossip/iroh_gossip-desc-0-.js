searchState.loadedDescShard("iroh_gossip", 0, "iroh-gossip\nALPN protocol name\nPublic API for using iroh-gossip\nMetrics for iroh-gossip\nNetworking for the <code>iroh-gossip</code> protocol\nImplementation of the iroh-gossip protocol, as an IO-less …\nBroadcasts a message to all nodes in the swarm.\nBroadcasts a message to all direct neighbors.\nThe gossip topic was closed.\nCommand for a gossip topic.\nEvents emitted from a gossip topic.\nAPI to control a <code>Gossip</code> instance.\nReceiver for gossip events on a topic.\nSender for a gossip topic.\nSubscribed gossip topic.\nOptions for joining a gossip topic.\nConnects to a set of peers.\nWe missed some messages because our <code>GossipReceiver</code> was not …\nA gossip message\nWe dropped direct neighbor in the swarm membership layer …\nWe have a new, direct neighbor in the swarm membership …\nWe received a gossip message for this topic.\nThe initial bootstrap nodes.\nBroadcasts a message to all nodes.\nSends a message to all peers.\nBroadcasts a message to our direct neighbors.\nSends a message to our direct neighbors in the swarm.\nThe content of the message\nThe node that delivered the message. This is not the same …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if we are connected to at least one node.\nReturns <code>true</code> if we are connected to at least one node.\nJoins a set of peers.\nWaits until we are connected to at least one node.\nWaits until we are connected to at least one node.\nLists our current direct neighbors.\nGet the parent span of the message\nThe scope of the message. This tells us if the message is …\nSplits <code>self</code> into <code>GossipSender</code> and <code>GossipReceiver</code> parts.\nJoin a gossip topic with the default options.\nJoin a gossip topic with the default options and wait for …\nJoin a gossip topic with options.\nThe maximum number of messages that can be buffered in a …\n<code>ToString::to_string</code>, but without panic on OOM.\nCreates <code>JoinOptions</code> with the provided bootstrap nodes and …\nEnum of metrics for the module\nNumber of times the actor ticked for a dialer event\nNumber of times the actor ticked for a failed dialer event\nNumber of times the actor ticked for a successful dialer …\nNumber of times the actor ticked for an endpoint event\nNumber of times the actor ticked for an incoming event\nNumber of times the main actor loop ticked\nNumber of times the actor ticked for a message received\nNumber of times the actor ticked for a timer event\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNumber of control messages received\nTotal size of all control messages received\nNumber of control messages sent\nTotal size of all control messages sent\nNumber of data messages received\nTotal size of all data messages received\nNumber of data messages sent\nTotal size of all data messages sent\nNumber of times we disconnected from a peer\nNumber of times we connected to a peer\nBroadcast a message for this topic.\nBuilder to configure and construct <code>Gossip</code>.\nALPN protocol name\nPublish and subscribe on gossiping topics.\nJoin this topic and connect to peers.\nWe dropped direct neighbor in the swarm membership layer …\nWe have a new, direct neighbor in the swarm membership …\nCommands for the gossip protocol\nEvents emitted from the gossip protocol\nLeave this topic and drop all state.\nA gossip message was received for this topic\nSet the broadcast configuration.\nCreates a default <code>Builder</code>, with the endpoint set.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHandle an incoming <code>Connection</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the maximum message size configured for this gossip …\nSets the maximum message size in bytes. By default this is …\nSet the membership configuration.\nReturns the metrics tracked for this gossip instance.\nShutdown the gossip instance.\nSpawn a gossip actor and get a handle for it\n<code>ToString::to_string</code>, but without panic on OOM.\nThe default maximum size in bytes for a gossip message. …\nThe scope to deliver the message to.\nConfiguration for the swarm membership layer\nThe minimum allowed value for <code>Config::max_message_size</code>.\nThis message was received from a direct neighbor that …\nThe message is broadcast only to the immediate neighbors …\nOpaque binary data that is transmitted on messages that …\nThe identifier for a peer.\nConfiguration for the gossip broadcast layer.\nThe broadcast scope of a gossip message.\nThis message was received from the swarm, with a distance …\nThe message is broadcast to all peers in the swarm.\nNumber of hops a <code>ForwardJoin</code> message is propagated until …\nNumber of peers to which active connections are maintained\nGet the peer data as a byte slice.\nHow often the internal caches will be checked for expired …\nDefault values for the HyParView layer\nSensible defaults for the plumtree configuration\nTimeout after which <code>IHave</code> messages are pushed to peers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhen receiving an <code>IHave</code> message, this timeout is …\nThis timeout is registered when sending a <code>Graft</code> message. …\nGet a reference to the contained <code>bytes::Bytes</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this message was directly received from its …\nDuration for which to keep gossip messages in the internal …\nDuration for which to keep the <code>MessageId</code>s for received …\nTimeout after which a <code>Neighbor</code> request is considered failed\nCreate a new <code>PeerData</code> from a byte buffer.\nThe protocol performs a tree optimization, which promotes …\nNumber of hops a <code>ForwardJoin</code> message is propagated until …\nNumber of peers for which contact information is …\nNumber of active peers to be included in a <code>Shuffle</code> request.\nInterval duration for shuffle requests\nNumber of passive peers to be included in a <code>Shuffle</code> …\nNumber of hops a <code>Shuffle</code> message is propagated until a …\nThe protocol state of the <code>iroh-gossip</code> protocol.\nThis module contains the implementation of the gossiping …\nUtilities used in the protocol implementation\nExecute a command from the application.\nA control message.\nA data message.\nClose the connection to a peer on the network level.\nEmit an event to the application.\nInput event to the protocol state.\nProtocol wire message\nWhether this is a control or data message\nOutput event from the protocol state.\nUpdated peer data\nPeer disconnected on the network level.\nMessage received from the network.\nSchedule a timer. The runtime is responsible for sending …\nSend a message on the network\nThe state of the <code>iroh-gossip</code> protocol.\nA timer to be registered into the runtime\nTrigger a previously scheduled timer.\nThe identifier for a topic\nUpdate the opaque peer data about yourself.\nGet as byte slice.\nConvert to a hex string limited to the first 5 bytes for a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate from a byte array.\nHandle an <code>InEvent</code>\nCheck if a topic has any active (connected) peers.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the kind of this message\nReturns the maximum message size configured in the gossip …\nGet a reference to the node’s <code>PeerIdentity</code>\nCreate a new protocol state instance.\nResets the tracked stats for a topic.\nGet the encoded size of this message\nGet a reference to the protocol state for a topic.\nGet an iterator for the states of all joined topics.\nGet an iterator of all joined topics.\n<code>ToString::to_string</code>, but without panic on OOM.\nBroadcast a message for this topic.\nA command to the protocol state for a particular topic.\nExecute a command from the application.\nProtocol configuration\nClose the connection to a peer on the network level.\nEmit an event to the application.\nAn event to be emitted to the application for a particular …\nA message of the gossip broadcast layer\nA timer for the gossip layer\nA trait for a concrete type to push <code>OutEvent</code>s to.\nInput event to the topic state handler.\nJoin this topic and connect to peers.\nA protocol message for a particular topic\nWe dropped direct neighbor in the swarm membership layer …\nWe have a new, direct neighbor in the swarm membership …\nAn output event from the state handler.\nEmitted when new <code>PeerData</code> was received for a peer.\nPeer disconnected on the network level.\nLeave this topic and drop all state.\nA gossip message was received for this topic\nMessage received from the network.\nSchedule a timer. The runtime is responsible for sending …\nSend a message on the network\nThe topic state maintains the swarm membership and …\nStatistics for the protocol state of a topic\nA message of the swarm membership layer\nA timer for the swarm layer\nA timer to be registered for a particular topic.\nTrigger a previously scheduled timer.\nUpdate the opaque peer data about yourself.\nConfiguration for the gossip broadcast layer\nThe address of your local endpoint.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet statistics for the gossip broadcast state\nHandle an incoming event.\nCheck if this topic has any active (connected) peers.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this is a disconnect message (which is the …\nGet the kind of this message\nMax message size in bytes.\nConfiguration for the swarm membership layer\nNumber of messages received\nNumber of messages sent\nInitialize the local state with the default random number …\nPush an event in the IO container\nPush all events from an iterator into the IO container\nReset all statistics.\nGet stats on how many messages were sent and received.\nInitialize the local state with a custom random number …\nA hash map where entries expire after a time\nA <code>BinaryHeap</code> with entries sorted by <code>Instant</code>. Allows to …\nReturns <code>true</code> if the map contains a value for the specified …\nRemove and return all entries before and equal to <code>from</code>.\nRemove all entries with an expiry instant lower or equal …\nGet the expiration time for an item.\nGet a reference to the earliest entry in the <code>TimerMap</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet an item from the cache.\nInsert a new entry at the specified instant.\nInsert an item into the cache, marked with an expiration …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the map contains no elements.\nIterate over all items in the cache.\nGet the number of entries in the cache.\nCreate a new, empty TimerMap.\nPop the first entry, if equal or before <code>limit</code>.")