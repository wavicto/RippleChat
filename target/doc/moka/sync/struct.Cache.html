<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A thread-safe concurrent synchronous in-memory cache."><title>Cache in moka::sync - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="moka" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../static.files/storage-82c7156e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../moka/index.html">moka</a><span class="version">0.12.10</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Cache</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#table-of-contents" title="Table of Contents">Table of Contents</a></li><li><a href="#example-insert-get-and-invalidate" title="Example: `insert`, `get` and `invalidate`">Example: <code>insert</code>, <code>get</code> and <code>invalidate</code></a></li><li><a href="#avoiding-to-clone-the-value-at-get" title="Avoiding to clone the value at `get`">Avoiding to clone the value at <code>get</code></a></li><li><a href="#sharing-a-cache-across-threads" title="Sharing a cache across threads">Sharing a cache across threads</a><ul><li><a href="#no-lock-is-needed" title="No lock is needed">No lock is needed</a></li></ul></li><li><a href="#hashing-algorithm" title="Hashing Algorithm">Hashing Algorithm</a></li><li><a href="#example-size-based-eviction" title="Example: Size-based Eviction">Example: Size-based Eviction</a></li><li><a href="#example-time-based-expirations" title="Example: Time-based Expirations">Example: Time-based Expirations</a><ul><li><a href="#cache-level-ttl-and-tti-policies" title="Cache-level TTL and TTI policies">Cache-level TTL and TTI policies</a></li><li><a href="#per-entry-expiration-policy" title="Per-entry expiration policy">Per-entry expiration policy</a></li></ul></li><li><a href="#example-eviction-listener" title="Example: Eviction Listener">Example: Eviction Listener</a><ul><li><a href="#you-should-avoid-eviction-listener-to-panic" title="You should avoid eviction listener to panic">You should avoid eviction listener to panic</a></li></ul></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.builder" title="builder">builder</a></li><li><a href="#method.contains_key" title="contains_key">contains_key</a></li><li><a href="#method.entry" title="entry">entry</a></li><li><a href="#method.entry_by_ref" title="entry_by_ref">entry_by_ref</a></li><li><a href="#method.entry_count" title="entry_count">entry_count</a></li><li><a href="#method.get" title="get">get</a></li><li><a href="#method.get_with" title="get_with">get_with</a></li><li><a href="#method.get_with_by_ref" title="get_with_by_ref">get_with_by_ref</a></li><li><a href="#method.get_with_if" title="get_with_if">get_with_if</a></li><li><a href="#method.insert" title="insert">insert</a></li><li><a href="#method.invalidate" title="invalidate">invalidate</a></li><li><a href="#method.invalidate_all" title="invalidate_all">invalidate_all</a></li><li><a href="#method.invalidate_entries_if" title="invalidate_entries_if">invalidate_entries_if</a></li><li><a href="#method.iter" title="iter">iter</a></li><li><a href="#method.name" title="name">name</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.optionally_get_with" title="optionally_get_with">optionally_get_with</a></li><li><a href="#method.optionally_get_with_by_ref" title="optionally_get_with_by_ref">optionally_get_with_by_ref</a></li><li><a href="#method.policy" title="policy">policy</a></li><li><a href="#method.remove" title="remove">remove</a></li><li><a href="#method.run_pending_tasks" title="run_pending_tasks">run_pending_tasks</a></li><li><a href="#method.try_get_with" title="try_get_with">try_get_with</a></li><li><a href="#method.try_get_with_by_ref" title="try_get_with_by_ref">try_get_with_by_ref</a></li><li><a href="#method.weighted_size" title="weighted_size">weighted_size</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Cache%3CK,+V,+S%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-Cache%3CK,+V,+S%3E" title="Debug">Debug</a></li><li><a href="#impl-IntoIterator-for-%26Cache%3CK,+V,+S%3E" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-Send-for-Cache%3CK,+V,+S%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-Cache%3CK,+V,+S%3E" title="Sync">Sync</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-Cache%3CK,+V,+S%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-Cache%3CK,+V,+S%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-Cache%3CK,+V,+S%3E" title="Freeze">Freeze</a></li><li><a href="#impl-Unpin-for-Cache%3CK,+V,+S%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-Pointable-for-T" title="Pointable">Pointable</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In moka::<wbr>sync</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">moka</a>::<wbr><a href="index.html">sync</a></div><h1>Struct <span class="struct">Cache</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/moka/sync/cache.rs.html#573-576">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Cache&lt;K, V, S = <a class="struct" href="https://doc.rust-lang.org/1.87.0/std/hash/random/struct.RandomState.html" title="struct std::hash::random::RandomState">RandomState</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A thread-safe concurrent synchronous in-memory cache.</p>
<p><code>Cache</code> supports full concurrency of retrievals and a high expected concurrency
for updates.</p>
<p><code>Cache</code> utilizes a lock-free concurrent hash table as the central key-value
storage. <code>Cache</code> performs a best-effort bounding of the map using an entry
replacement algorithm to determine which entries to evict when the capacity is
exceeded.</p>
<h2 id="table-of-contents"><a class="doc-anchor" href="#table-of-contents">ยง</a>Table of Contents</h2>
<ul>
<li><a href="#example-insert-get-and-invalidate">Example: <code>insert</code>, <code>get</code> and <code>invalidate</code></a></li>
<li><a href="#avoiding-to-clone-the-value-at-get">Avoiding to clone the value at <code>get</code></a></li>
<li><a href="#sharing-a-cache-across-threads">Sharing a cache across threads</a>
<ul>
<li><a href="#no-lock-is-needed">No lock is needed</a></li>
</ul>
</li>
<li><a href="#hashing-algorithm">Hashing Algorithm</a></li>
<li><a href="#example-size-based-eviction">Example: Size-based Eviction</a></li>
<li><a href="#example-time-based-expirations">Example: Time-based Expirations</a>
<ul>
<li><a href="#cache-level-ttl-and-tti-policies">Cache-level TTL and TTI policies</a></li>
<li><a href="#per-entry-expiration-policy">Per-entry expiration policy</a></li>
</ul>
</li>
<li><a href="#example-eviction-listener">Example: Eviction Listener</a>
<ul>
<li><a href="#you-should-avoid-eviction-listener-to-panic">You should avoid eviction listener to
panic</a></li>
</ul>
</li>
</ul>
<h2 id="example-insert-get-and-invalidate"><a class="doc-anchor" href="#example-insert-get-and-invalidate">ยง</a>Example: <code>insert</code>, <code>get</code> and <code>invalidate</code></h2>
<p>Cache entries are manually added using <a href="#method.insert"><code>insert</code></a> or
<a href="#method.get_with"><code>get_with</code></a> methods, and are stored in the cache until either
evicted or manually invalidated.</p>
<p>Hereโs an example of reading and updating a cache by using multiple threads:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;

<span class="kw">use </span>std::thread;

<span class="kw">fn </span>value(n: usize) -&gt; String {
    <span class="macro">format!</span>(<span class="string">"value {n}"</span>)
}

<span class="kw">const </span>NUM_THREADS: usize = <span class="number">16</span>;
<span class="kw">const </span>NUM_KEYS_PER_THREAD: usize = <span class="number">64</span>;

<span class="comment">// Create a cache that can store up to 10,000 entries.
</span><span class="kw">let </span>cache = Cache::new(<span class="number">10_000</span>);

<span class="comment">// Spawn threads and read and update the cache simultaneously.
</span><span class="kw">let </span>threads: Vec&lt;<span class="kw">_</span>&gt; = (<span class="number">0</span>..NUM_THREADS)
    .map(|i| {
        <span class="comment">// To share the same cache across the threads, clone it.
        // This is a cheap operation.
        </span><span class="kw">let </span>my_cache = cache.clone();
        <span class="kw">let </span>start = i * NUM_KEYS_PER_THREAD;
        <span class="kw">let </span>end = (i + <span class="number">1</span>) * NUM_KEYS_PER_THREAD;

        thread::spawn(<span class="kw">move </span>|| {
            <span class="comment">// Insert 64 entries. (NUM_KEYS_PER_THREAD = 64)
            </span><span class="kw">for </span>key <span class="kw">in </span>start..end {
                my_cache.insert(key, value(key));
                <span class="comment">// get() returns Option&lt;String&gt;, a clone of the stored value.
                </span><span class="macro">assert_eq!</span>(my_cache.get(<span class="kw-2">&amp;</span>key), <span class="prelude-val">Some</span>(value(key)));
            }

            <span class="comment">// Invalidate every 4 element of the inserted entries.
            </span><span class="kw">for </span>key <span class="kw">in </span>(start..end).step_by(<span class="number">4</span>) {
                my_cache.invalidate(<span class="kw-2">&amp;</span>key);
            }
        })
    })
    .collect();

<span class="comment">// Wait for all threads to complete.
</span>threads.into_iter().for_each(|t| t.join().expect(<span class="string">"Failed"</span>));

<span class="comment">// Verify the result.
</span><span class="kw">for </span>key <span class="kw">in </span><span class="number">0</span>..(NUM_THREADS * NUM_KEYS_PER_THREAD) {
    <span class="kw">if </span>key % <span class="number">4 </span>== <span class="number">0 </span>{
        <span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span>key), <span class="prelude-val">None</span>);
    } <span class="kw">else </span>{
        <span class="macro">assert_eq!</span>(cache.get(<span class="kw-2">&amp;</span>key), <span class="prelude-val">Some</span>(value(key)));
    }
}</code></pre></div>
<p>If you want to atomically initialize and insert a value when the key is not
present, you might want to check other insertion methods
<a href="#method.get_with"><code>get_with</code></a> and <a href="#method.try_get_with"><code>try_get_with</code></a>.</p>
<h2 id="avoiding-to-clone-the-value-at-get"><a class="doc-anchor" href="#avoiding-to-clone-the-value-at-get">ยง</a>Avoiding to clone the value at <code>get</code></h2>
<p>The return type of <code>get</code> method is <code>Option&lt;V&gt;</code> instead of <code>Option&lt;&amp;V&gt;</code>. Every
time <code>get</code> is called for an existing key, it creates a clone of the stored value
<code>V</code> and returns it. This is because the <code>Cache</code> allows concurrent updates from
threads so a value stored in the cache can be dropped or replaced at any time by
any other thread. <code>get</code> cannot return a reference <code>&amp;V</code> as it is impossible to
guarantee the value outlives the reference.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<h2 id="sharing-a-cache-across-threads"><a class="doc-anchor" href="#sharing-a-cache-across-threads">ยง</a>Sharing a cache across threads</h2>
<p>To share a cache across threads, do one of the followings:</p>
<ul>
<li>Create a clone of the cache by calling its <code>clone</code> method and pass it to other
thread.</li>
<li>Wrap the cache by a <code>sync::OnceCell</code> or <code>sync::Lazy</code> from
<a href="https://crates.io/crates/once_cell">once_cell</a> create, and set it to a <code>static</code> variable.</li>
</ul>
<p>Cloning is a cheap operation for <code>Cache</code> as it only creates thread-safe
reference-counted pointers to the internal data structures.</p>
<h3 id="no-lock-is-needed"><a class="doc-anchor" href="#no-lock-is-needed">ยง</a>No lock is needed</h3>
<p>Donโt wrap a <code>Cache</code> by a lock such as <code>Mutex</code> or <code>RwLock</code>. All methods provided
by the <code>Cache</code> are considered thread-safe, and can be safely called by multiple
threads at the same time. No lock is needed.</p>
<h2 id="hashing-algorithm"><a class="doc-anchor" href="#hashing-algorithm">ยง</a>Hashing Algorithm</h2>
<p>By default, <code>Cache</code> uses a hashing algorithm selected to provide resistance
against HashDoS attacks. It will be the same one used by
<code>std::collections::HashMap</code>, which is currently SipHash 1-3.</p>
<p>While SipHashโs performance is very competitive for medium sized keys, other
hashing algorithms will outperform it for small keys such as integers as well as
large keys such as long strings. However those algorithms will typically not
protect against attacks such as HashDoS.</p>
<p>The hashing algorithm can be replaced on a per-<code>Cache</code> basis using the
<a href="./struct.CacheBuilder.html#method.build_with_hasher"><code>build_with_hasher</code></a> method of the <code>CacheBuilder</code>.
Many alternative algorithms are available on crates.io, such as the
<a href="https://crates.io/crates/ahash">AHash</a> crate.</p>
<h2 id="example-size-based-eviction"><a class="doc-anchor" href="#example-size-based-eviction">ยง</a>Example: Size-based Eviction</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;

<span class="comment">// Evict based on the number of entries in the cache.
</span><span class="kw">let </span>cache = Cache::builder()
    <span class="comment">// Up to 10,000 entries.
    </span>.max_capacity(<span class="number">10_000</span>)
    <span class="comment">// Create the cache.
    </span>.build();
cache.insert(<span class="number">1</span>, <span class="string">"one"</span>.to_string());

<span class="comment">// Evict based on the byte length of strings in the cache.
</span><span class="kw">let </span>cache = Cache::builder()
    <span class="comment">// A weigher closure takes &amp;K and &amp;V and returns a u32
    // representing the relative size of the entry.
    </span>.weigher(|_key, value: <span class="kw-2">&amp;</span>String| -&gt; u32 {
        value.len().try_into().unwrap_or(u32::MAX)
    })
    <span class="comment">// This cache will hold up to 32MiB of values.
    </span>.max_capacity(<span class="number">32 </span>* <span class="number">1024 </span>* <span class="number">1024</span>)
    .build();
cache.insert(<span class="number">2</span>, <span class="string">"two"</span>.to_string());</code></pre></div>
<p>If your cache should not grow beyond a certain size, use the <code>max_capacity</code>
method of the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a> to set the upper bound. The cache
will try to evict entries that have not been used recently or very often.</p>
<p>At the cache creation time, a weigher closure can be set by the <code>weigher</code> method
of the <code>CacheBuilder</code>. A weigher closure takes <code>&amp;K</code> and <code>&amp;V</code> as the arguments and
returns a <code>u32</code> representing the relative size of the entry:</p>
<ul>
<li>If the <code>weigher</code> is <em>not</em> set, the cache will treat each entry has the same
size of <code>1</code>. This means the cache will be bounded by the number of entries.</li>
<li>If the <code>weigher</code> is set, the cache will call the weigher to calculate the
weighted size (relative size) on an entry. This means the cache will be bounded
by the total weighted size of entries.</li>
</ul>
<p>Note that weighted sizes are not used when making eviction selections.</p>
<h2 id="example-time-based-expirations"><a class="doc-anchor" href="#example-time-based-expirations">ยง</a>Example: Time-based Expirations</h2><h3 id="cache-level-ttl-and-tti-policies"><a class="doc-anchor" href="#cache-level-ttl-and-tti-policies">ยง</a>Cache-level TTL and TTI policies</h3>
<p><code>Cache</code> supports the following cache-level expiration policies:</p>
<ul>
<li><strong>Time to live (TTL)</strong>: A cached entry will be expired after the specified
duration past from <code>insert</code>.</li>
<li><strong>Time to idle (TTI)</strong>: A cached entry will be expired after the specified
duration past from <code>get</code> or <code>insert</code>.</li>
</ul>
<p>They are a cache-level expiration policies; all entries in the cache will have
the same TTL and/or TTI durations. If you want to set different expiration
durations for different entries, see the next section.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;
<span class="kw">use </span>std::time::Duration;

<span class="kw">let </span>cache = Cache::builder()
    <span class="comment">// Time to live (TTL): 30 minutes
    </span>.time_to_live(Duration::from_secs(<span class="number">30 </span>* <span class="number">60</span>))
    <span class="comment">// Time to idle (TTI):  5 minutes
    </span>.time_to_idle(Duration::from_secs( <span class="number">5 </span>* <span class="number">60</span>))
    <span class="comment">// Create the cache.
    </span>.build();

<span class="comment">// This entry will expire after 5 minutes (TTI) if there is no get().
</span>cache.insert(<span class="number">0</span>, <span class="string">"zero"</span>);

<span class="comment">// This get() will extend the entry life for another 5 minutes.
</span>cache.get(<span class="kw-2">&amp;</span><span class="number">0</span>);

<span class="comment">// Even though we keep calling get(), the entry will expire
// after 30 minutes (TTL) from the insert().</span></code></pre></div>
<h3 id="per-entry-expiration-policy"><a class="doc-anchor" href="#per-entry-expiration-policy">ยง</a>Per-entry expiration policy</h3>
<p><code>Cache</code> supports per-entry expiration policy through the <code>Expiry</code> trait.</p>
<p><code>Expiry</code> trait provides three callback methods:
<a href="../trait.Expiry.html#method.expire_after_create"><code>expire_after_create</code></a>, <a href="../trait.Expiry.html#method.expire_after_read"><code>expire_after_read</code></a> and
<a href="../trait.Expiry.html#method.expire_after_update"><code>expire_after_update</code></a>. When a cache entry is inserted, read or
updated, one of these methods is called. These methods return an
<code>Option&lt;Duration&gt;</code>, which is used as the expiration duration of the entry.</p>
<p><code>Expiry</code> trait provides the default implementations of these methods, so you will
implement only the methods you want to customize.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::{sync::Cache, Expiry};
<span class="kw">use </span>std::time::{Duration, Instant};

<span class="comment">// In this example, we will create a `sync::Cache` with `u32` as the key, and
// `(Expiration, String)` as the value. `Expiration` is an enum to represent the
// expiration of the value, and `String` is the application data of the value.

</span><span class="doccomment">/// An enum to represent the expiration of a value.
</span><span class="attr">#[derive(Clone, Copy, Debug, Eq, PartialEq)]
</span><span class="kw">pub enum </span>Expiration {
    <span class="doccomment">/// The value never expires.
    </span>Never,
    <span class="doccomment">/// The value expires after a short time. (5 seconds in this example)
    </span>AfterShortTime,
    <span class="doccomment">/// The value expires after a long time. (15 seconds in this example)
    </span>AfterLongTime,
}

<span class="kw">impl </span>Expiration {
    <span class="doccomment">/// Returns the duration of this expiration.
    </span><span class="kw">pub fn </span>as_duration(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;Duration&gt; {
        <span class="kw">match </span><span class="self">self </span>{
            Expiration::Never =&gt; <span class="prelude-val">None</span>,
            Expiration::AfterShortTime =&gt; <span class="prelude-val">Some</span>(Duration::from_secs(<span class="number">5</span>)),
            Expiration::AfterLongTime =&gt; <span class="prelude-val">Some</span>(Duration::from_secs(<span class="number">15</span>)),
        }
    }
}

<span class="doccomment">/// An expiry that implements `moka::Expiry` trait. `Expiry` trait provides the
/// default implementations of three callback methods `expire_after_create`,
/// `expire_after_read`, and `expire_after_update`.
///
/// In this example, we only override the `expire_after_create` method.
</span><span class="kw">pub struct </span>MyExpiry;

<span class="kw">impl </span>Expiry&lt;u32, (Expiration, String)&gt; <span class="kw">for </span>MyExpiry {
    <span class="doccomment">/// Returns the duration of the expiration of the value that was just
    /// created.
    </span><span class="kw">fn </span>expire_after_create(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        _key: <span class="kw-2">&amp;</span>u32,
        value: <span class="kw-2">&amp;</span>(Expiration, String),
        _current_time: Instant,
    ) -&gt; <span class="prelude-ty">Option</span>&lt;Duration&gt; {
        <span class="kw">let </span>duration = value.<span class="number">0</span>.as_duration();
        <span class="macro">println!</span>(<span class="string">"MyExpiry: expire_after_create called with key {_key} and value {value:?}. Returning {duration:?}."</span>);
        duration
    }
}

<span class="comment">// Create a `Cache&lt;u32, (Expiration, String)&gt;` with an expiry `MyExpiry` and
// eviction listener.
</span><span class="kw">let </span>expiry = MyExpiry;

<span class="kw">let </span>eviction_listener = |key, _value, cause| {
    <span class="macro">println!</span>(<span class="string">"Evicted key {key}. Cause: {cause:?}"</span>);
};

<span class="kw">let </span>cache = Cache::builder()
    .max_capacity(<span class="number">100</span>)
    .expire_after(expiry)
    .eviction_listener(eviction_listener)
    .build();

<span class="comment">// Insert some entries into the cache with different expirations.
</span>cache.get_with(<span class="number">0</span>, || (Expiration::AfterShortTime, <span class="string">"a"</span>.to_string()));
cache.get_with(<span class="number">1</span>, || (Expiration::AfterLongTime, <span class="string">"b"</span>.to_string()));
cache.get_with(<span class="number">2</span>, || (Expiration::Never, <span class="string">"c"</span>.to_string()));

<span class="comment">// Verify that all the inserted entries exist.
</span><span class="macro">assert!</span>(cache.contains_key(<span class="kw-2">&amp;</span><span class="number">0</span>));
<span class="macro">assert!</span>(cache.contains_key(<span class="kw-2">&amp;</span><span class="number">1</span>));
<span class="macro">assert!</span>(cache.contains_key(<span class="kw-2">&amp;</span><span class="number">2</span>));

<span class="comment">// Sleep for 6 seconds. Key 0 should expire.
</span><span class="macro">println!</span>(<span class="string">"\nSleeping for 6 seconds...\n"</span>);
std::thread::sleep(Duration::from_secs(<span class="number">6</span>));
<span class="macro">println!</span>(<span class="string">"Entry count: {}"</span>, cache.entry_count());

<span class="comment">// Verify that key 0 has been evicted.
</span><span class="macro">assert!</span>(!cache.contains_key(<span class="kw-2">&amp;</span><span class="number">0</span>));
<span class="macro">assert!</span>(cache.contains_key(<span class="kw-2">&amp;</span><span class="number">1</span>));
<span class="macro">assert!</span>(cache.contains_key(<span class="kw-2">&amp;</span><span class="number">2</span>));

<span class="comment">// Sleep for 10 more seconds. Key 1 should expire.
</span><span class="macro">println!</span>(<span class="string">"\nSleeping for 10 seconds...\n"</span>);
std::thread::sleep(Duration::from_secs(<span class="number">10</span>));
<span class="macro">println!</span>(<span class="string">"Entry count: {}"</span>, cache.entry_count());

<span class="comment">// Verify that key 1 has been evicted.
</span><span class="macro">assert!</span>(!cache.contains_key(<span class="kw-2">&amp;</span><span class="number">1</span>));
<span class="macro">assert!</span>(cache.contains_key(<span class="kw-2">&amp;</span><span class="number">2</span>));

<span class="comment">// Manually invalidate key 2.
</span>cache.invalidate(<span class="kw-2">&amp;</span><span class="number">2</span>);
<span class="macro">assert!</span>(!cache.contains_key(<span class="kw-2">&amp;</span><span class="number">2</span>));

<span class="macro">println!</span>(<span class="string">"\nSleeping for a second...\n"</span>);
std::thread::sleep(Duration::from_secs(<span class="number">1</span>));
<span class="macro">println!</span>(<span class="string">"Entry count: {}"</span>, cache.entry_count());

<span class="macro">println!</span>(<span class="string">"\nDone!"</span>);</code></pre></div>
<h2 id="example-eviction-listener"><a class="doc-anchor" href="#example-eviction-listener">ยง</a>Example: Eviction Listener</h2>
<p>A <code>Cache</code> can be configured with an eviction listener, a closure that is called
every time there is a cache eviction. The listener takes three parameters: the
key and value of the evicted entry, and the
<a href="../notification/enum.RemovalCause.html"><code>RemovalCause</code></a> to indicate why the
entry was evicted.</p>
<p>An eviction listener can be used to keep other data structures in sync with the
cache, for example.</p>
<p>The following example demonstrates how to use an eviction listener with
time-to-live expiration to manage the lifecycle of temporary files on a
filesystem. The cache stores the paths of the files, and when one of them has
expired, the eviction listener will be called with the path, so it can remove the
file from the filesystem.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Cargo.toml
//
// [dependencies]
// anyhow = "1.0"
// uuid = { version = "1.1", features = ["v4"] }

</span><span class="kw">use </span>moka::{sync::Cache, notification};

<span class="kw">use </span>anyhow::{anyhow, Context};
<span class="kw">use </span>std::{
    fs, io,
    path::{Path, PathBuf},
    sync::{Arc, RwLock},
    time::Duration,
};
<span class="kw">use </span>uuid::Uuid;

<span class="doccomment">/// The DataFileManager writes, reads and removes data files.
</span><span class="kw">struct </span>DataFileManager {
    base_dir: PathBuf,
    file_count: usize,
}

<span class="kw">impl </span>DataFileManager {
    <span class="kw">fn </span>new(base_dir: PathBuf) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{
            base_dir,
            file_count: <span class="number">0</span>,
        }
    }

    <span class="kw">fn </span>write_data_file(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        key: <span class="kw">impl </span>AsRef&lt;str&gt;,
        contents: String
    ) -&gt; io::Result&lt;PathBuf&gt; {
        <span class="comment">// Use the key as a part of the filename.
        </span><span class="kw">let </span><span class="kw-2">mut </span>path = <span class="self">self</span>.base_dir.to_path_buf();
        path.push(key.as_ref());

        <span class="macro">assert!</span>(!path.exists(), <span class="string">"Path already exists: {path:?}"</span>);

        <span class="comment">// create the file at the path and write the contents to the file.
        </span>fs::write(<span class="kw-2">&amp;</span>path, contents)<span class="question-mark">?</span>;
        <span class="self">self</span>.file_count += <span class="number">1</span>;
        <span class="macro">println!</span>(<span class="string">"Created a data file at {path:?} (file count: {})"</span>, <span class="self">self</span>.file_count);
        <span class="prelude-val">Ok</span>(path)
    }

    <span class="kw">fn </span>read_data_file(<span class="kw-2">&amp;</span><span class="self">self</span>, path: <span class="kw">impl </span>AsRef&lt;Path&gt;) -&gt; io::Result&lt;String&gt; {
        <span class="comment">// Reads the contents of the file at the path, and return the contents.
        </span>fs::read_to_string(path)
    }

    <span class="kw">fn </span>remove_data_file(<span class="kw-2">&amp;mut </span><span class="self">self</span>, path: <span class="kw">impl </span>AsRef&lt;Path&gt;) -&gt; io::Result&lt;()&gt; {
        <span class="comment">// Remove the file at the path.
        </span>fs::remove_file(path.as_ref())<span class="question-mark">?</span>;
        <span class="self">self</span>.file_count -= <span class="number">1</span>;
        <span class="macro">println!</span>(
            <span class="string">"Removed a data file at {:?} (file count: {})"</span>,
            path.as_ref(),
            <span class="self">self</span>.file_count
        );

        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">fn </span>main() -&gt; anyhow::Result&lt;()&gt; {
    <span class="comment">// Create an instance of the DataFileManager and wrap it with
    // Arc&lt;RwLock&lt;_&gt;&gt; so it can be shared across threads.
    </span><span class="kw">let </span><span class="kw-2">mut </span>base_dir = std::env::temp_dir();
    base_dir.push(Uuid::new_v4().as_hyphenated().to_string());
    <span class="macro">println!</span>(<span class="string">"base_dir: {base_dir:?}"</span>);
    std::fs::create_dir(<span class="kw-2">&amp;</span>base_dir)<span class="question-mark">?</span>;

    <span class="kw">let </span>file_mgr = DataFileManager::new(base_dir);
    <span class="kw">let </span>file_mgr = Arc::new(RwLock::new(file_mgr));

    <span class="kw">let </span>file_mgr1 = Arc::clone(<span class="kw-2">&amp;</span>file_mgr);

    <span class="comment">// Create an eviction listener closure.
    </span><span class="kw">let </span>eviction_listener = <span class="kw">move </span>|k, v: PathBuf, cause| {
        <span class="comment">// Try to remove the data file at the path `v`.
        </span><span class="macro">println!</span>(<span class="string">"\n== An entry has been evicted. k: {k:?}, v: {v:?}, cause: {cause:?}"</span>);

        <span class="comment">// Acquire the write lock of the DataFileManager. We must handle
        // error cases here to prevent the listener from panicking.
        </span><span class="kw">match </span>file_mgr1.write() {
            <span class="prelude-val">Err</span>(_e) =&gt; {
                <span class="macro">eprintln!</span>(<span class="string">"The lock has been poisoned"</span>);
            }
            <span class="prelude-val">Ok</span>(<span class="kw-2">mut </span>mgr) =&gt; {
                <span class="comment">// Remove the data file using the DataFileManager.
                </span><span class="kw">if let </span><span class="prelude-val">Err</span>(_e) = mgr.remove_data_file(v.as_path()) {
                    <span class="macro">eprintln!</span>(<span class="string">"Failed to remove a data file at {v:?}"</span>);
                }
            }
        }
    };

    <span class="comment">// Create the cache. Set time to live for two seconds and set the
    // eviction listener.
    </span><span class="kw">let </span>cache = Cache::builder()
        .max_capacity(<span class="number">100</span>)
        .time_to_live(Duration::from_secs(<span class="number">2</span>))
        .eviction_listener(eviction_listener)
        .build();

    <span class="comment">// Insert an entry to the cache.
    // This will create and write a data file for the key "user1", store the
    // path of the file to the cache, and return it.
    </span><span class="macro">println!</span>(<span class="string">"== try_get_with()"</span>);
    <span class="kw">let </span>key = <span class="string">"user1"</span>;
    <span class="kw">let </span>path = cache
        .try_get_with(key, || -&gt; anyhow::Result&lt;<span class="kw">_</span>&gt; {
            <span class="kw">let </span><span class="kw-2">mut </span>mgr = file_mgr
                .write()
                .map_err(|_e| <span class="macro">anyhow::anyhow!</span>(<span class="string">"The lock has been poisoned"</span>))<span class="question-mark">?</span>;
            <span class="kw">let </span>path = mgr
                .write_data_file(key, <span class="string">"user data"</span>.into())
                .with_context(|| <span class="macro">format!</span>(<span class="string">"Failed to create a data file"</span>))<span class="question-mark">?</span>;
            <span class="prelude-val">Ok</span>(path)
        })
        .map_err(|e| <span class="macro">anyhow!</span>(<span class="string">"{e}"</span>))<span class="question-mark">?</span>;

    <span class="comment">// Read the data file at the path and print the contents.
    </span><span class="macro">println!</span>(<span class="string">"\n== read_data_file()"</span>);
    {
        <span class="kw">let </span>mgr = file_mgr
            .read()
            .map_err(|_e| <span class="macro">anyhow::anyhow!</span>(<span class="string">"The lock has been poisoned"</span>))<span class="question-mark">?</span>;
        <span class="kw">let </span>contents = mgr
            .read_data_file(path.as_path())
            .with_context(|| <span class="macro">format!</span>(<span class="string">"Failed to read data from {path:?}"</span>))<span class="question-mark">?</span>;
        <span class="macro">println!</span>(<span class="string">"contents: {contents}"</span>);
    }

    <span class="comment">// Sleep for five seconds. While sleeping, the cache entry for key "user1"
    // will be expired and evicted, so the eviction listener will be called to
    // remove the file.
    </span>std::thread::sleep(Duration::from_secs(<span class="number">5</span>));

    cache.run_pending_tasks();

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="you-should-avoid-eviction-listener-to-panic"><a class="doc-anchor" href="#you-should-avoid-eviction-listener-to-panic">ยง</a>You should avoid eviction listener to panic</h3>
<p>It is very important to make an eviction listener closure not to panic.
Otherwise, the cache will stop calling the listener after a panic. This is an
intended behavior because the cache cannot know whether it is memory safe or not
to call the panicked listener again.</p>
<p>When a listener panics, the cache will swallow the panic and disable the
listener. If you want to know when a listener panics and the reason of the panic,
you can enable an optional <code>logging</code> feature of Moka and check error-level logs.</p>
<p>To enable the <code>logging</code>, do the followings:</p>
<ol>
<li>In <code>Cargo.toml</code>, add the crate feature <code>logging</code> for <code>moka</code>.</li>
<li>Set the logging level for <code>moka</code> to <code>error</code> or any lower levels (<code>warn</code>,
<code>info</code>, โฆ):
<ul>
<li>If you are using the <code>env_logger</code> crate, you can achieve this by setting
<code>RUST_LOG</code> environment variable to <code>moka=error</code>.</li>
</ul>
</li>
<li>If you have more than one caches, you may want to set a distinct name for each
cache by using cache builderโs <a href="./struct.CacheBuilder.html#method.name"><code>name</code></a> method. The name
will appear in the log.</li>
</ol>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">ยง</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Cache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#628-688">Source</a><a href="#impl-Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.name" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#630-632">Source</a><h4 class="code-header">pub fn <a href="#method.name" class="fn">name</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns cacheโs name.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.policy" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#638-640">Source</a><h4 class="code-header">pub fn <a href="#method.policy" class="fn">policy</a>(&amp;self) -&gt; <a class="struct" href="../policy/struct.Policy.html" title="struct moka::policy::Policy">Policy</a></h4></section></summary><div class="docblock"><p>Returns a read-only cache policy of this cache.</p>
<p>At this time, cache policy cannot be modified after cache creation.
A future version may support to modify it.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.entry_count" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#675-677">Source</a><h4 class="code-header">pub fn <a href="#method.entry_count" class="fn">entry_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Returns an approximate number of entries in this cache.</p>
<p>The value returned is <em>an estimate</em>; the actual count may differ if there are
concurrent insertions or removals, or if some entries are pending removal due
to expiration. This inaccuracy can be mitigated by performing a <code>sync()</code>
first.</p>
<h5 id="example"><a class="doc-anchor" href="#example">ยง</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;

<span class="kw">let </span>cache = Cache::new(<span class="number">10</span>);
cache.insert(<span class="string">'n'</span>, <span class="string">"Netherland Dwarf"</span>);
cache.insert(<span class="string">'l'</span>, <span class="string">"Lop Eared"</span>);
cache.insert(<span class="string">'d'</span>, <span class="string">"Dutch"</span>);

<span class="comment">// Ensure an entry exists.
</span><span class="macro">assert!</span>(cache.contains_key(<span class="kw-2">&amp;</span><span class="string">'n'</span>));

<span class="comment">// However, followings may print stale number zeros instead of threes.
</span><span class="macro">println!</span>(<span class="string">"{}"</span>, cache.entry_count());   <span class="comment">// -&gt; 0
</span><span class="macro">println!</span>(<span class="string">"{}"</span>, cache.weighted_size()); <span class="comment">// -&gt; 0

// To mitigate the inaccuracy, Call `run_pending_tasks` method to run
// pending internal tasks.
</span>cache.run_pending_tasks();

<span class="comment">// Followings will print the actual numbers.
</span><span class="macro">println!</span>(<span class="string">"{}"</span>, cache.entry_count());   <span class="comment">// -&gt; 3
</span><span class="macro">println!</span>(<span class="string">"{}"</span>, cache.weighted_size()); <span class="comment">// -&gt; 3</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weighted_size" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#685-687">Source</a><h4 class="code-header">pub fn <a href="#method.weighted_size" class="fn">weighted_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Returns an approximate total weighted size of entries in this cache.</p>
<p>The value returned is <em>an estimate</em>; the actual size may differ if there are
concurrent insertions or removals, or if some entries are pending removal due
to expiration. This inaccuracy can be mitigated by performing a <code>sync()</code>
first. See <a href="#method.entry_count"><code>entry_count</code></a> for a sample code.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Cache%3CK,+V%3E" class="impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#690-725">Source</a><a href="#impl-Cache%3CK,+V%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.87.0/std/hash/random/struct.RandomState.html" title="struct std::hash::random::RandomState">RandomState</a>&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    V: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#701-716">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(max_capacity: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u64.html">u64</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new <code>Cache&lt;K, V&gt;</code> that will store up to the <code>max_capacity</code>.</p>
<p>To adjust various configuration knobs such as <code>initial_capacity</code> or
<code>time_to_live</code>, use the <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.builder" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#722-724">Source</a><h4 class="code-header">pub fn <a href="#method.builder" class="fn">builder</a>() -&gt; <a class="struct" href="struct.CacheBuilder.html" title="struct moka::sync::CacheBuilder">CacheBuilder</a>&lt;K, V, <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, <a class="struct" href="https://doc.rust-lang.org/1.87.0/std/hash/random/struct.RandomState.html" title="struct std::hash::random::RandomState">RandomState</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a <a href="./struct.CacheBuilder.html"><code>CacheBuilder</code></a>, which can builds a <code>Cache</code> or
<code>SegmentedCache</code> with various configuration knobs.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Cache%3CK,+V,+S%3E-1" class="impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#727-1787">Source</a><a href="#impl-Cache%3CK,+V,+S%3E-1" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S&gt; <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    V: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    S: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.contains_key" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#774-780">Source</a><h4 class="code-header">pub fn <a href="#method.contains_key" class="fn">contains_key</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;Q</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.bool.html">bool</a><div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    Q: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the cache contains a value for the key.</p>
<p>Unlike the <code>get</code> method, this method is not considered a cache read operation,
so it does not update the historic popularity estimator or reset the idle
timer for the key.</p>
<p>The key may be any borrowed form of the cacheโs key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#800-808">Source</a><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;Q</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    Q: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Returns a <em>clone</em> of the value corresponding to the key.</p>
<p>If you want to store values that will be expensive to clone, wrap them by
<code>std::sync::Arc</code> before storing in a cache. <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc</code></a> is a
thread-safe reference-counted pointer and its <code>clone()</code> method is cheap.</p>
<p>The key may be any borrowed form of the cacheโs key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.entry" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#841-847">Source</a><h4 class="code-header">pub fn <a href="#method.entry" class="fn">entry</a>(&amp;self, key: K) -&gt; <a class="struct" href="struct.OwnedKeyEntrySelector.html" title="struct moka::sync::OwnedKeyEntrySelector">OwnedKeyEntrySelector</a>&lt;'_, K, V, S&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a>,</div></h4></section></summary><div class="docblock"><p>Takes a key <code>K</code> and returns an <a href="./struct.OwnedKeyEntrySelector.html"><code>OwnedKeyEntrySelector</code></a> that can be used to
select or insert an entry.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">ยง</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;

<span class="kw">let </span>cache: Cache&lt;String, u32&gt; = Cache::new(<span class="number">100</span>);
<span class="kw">let </span>key = <span class="string">"key1"</span>.to_string();

<span class="kw">let </span>entry = cache.entry(key.clone()).or_insert(<span class="number">3</span>);
<span class="macro">assert!</span>(entry.is_fresh());
<span class="macro">assert_eq!</span>(entry.key(), <span class="kw-2">&amp;</span>key);
<span class="macro">assert_eq!</span>(entry.into_value(), <span class="number">3</span>);

<span class="kw">let </span>entry = cache.entry(key).or_insert(<span class="number">6</span>);
<span class="comment">// Not fresh because the value was already in the cache.
</span><span class="macro">assert!</span>(!entry.is_fresh());
<span class="macro">assert_eq!</span>(entry.into_value(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.entry_by_ref" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#872-879">Source</a><h4 class="code-header">pub fn <a href="#method.entry_by_ref" class="fn">entry_by_ref</a>&lt;'a, Q&gt;(
    &amp;'a self,
    key: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;'a Q</a>,
) -&gt; <a class="struct" href="struct.RefKeyEntrySelector.html" title="struct moka::sync::RefKeyEntrySelector">RefKeyEntrySelector</a>&lt;'a, K, Q, V, S&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    Q: <a class="trait" href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a>&lt;Owned = K&gt; + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Takes a reference <code>&amp;Q</code> of a key and returns an <a href="./struct.RefKeyEntrySelector.html"><code>RefKeyEntrySelector</code></a> that
can be used to select or insert an entry.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">ยง</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;

<span class="kw">let </span>cache: Cache&lt;String, u32&gt; = Cache::new(<span class="number">100</span>);
<span class="kw">let </span>key = <span class="string">"key1"</span>.to_string();

<span class="kw">let </span>entry = cache.entry_by_ref(<span class="kw-2">&amp;</span>key).or_insert(<span class="number">3</span>);
<span class="macro">assert!</span>(entry.is_fresh());
<span class="macro">assert_eq!</span>(entry.key(), <span class="kw-2">&amp;</span>key);
<span class="macro">assert_eq!</span>(entry.into_value(), <span class="number">3</span>);

<span class="kw">let </span>entry = cache.entry_by_ref(<span class="kw-2">&amp;</span>key).or_insert(<span class="number">6</span>);
<span class="comment">// Not fresh because the value was already in the cache.
</span><span class="macro">assert!</span>(!entry.is_fresh());
<span class="macro">assert_eq!</span>(entry.into_value(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_with" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#954-960">Source</a><h4 class="code-header">pub fn <a href="#method.get_with" class="fn">get_with</a>(&amp;self, key: K, init: impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V) -&gt; V</h4></section></summary><div class="docblock"><p>Returns a <em>clone</em> of the value corresponding to the key. If the value does
not exist, evaluates the <code>init</code> closure and inserts the output.</p>
<h5 id="concurrent-calls-on-the-same-key"><a class="doc-anchor" href="#concurrent-calls-on-the-same-key">ยง</a>Concurrent calls on the same key</h5>
<p>This method guarantees that concurrent calls on the same not-existing key are
coalesced into one evaluation of the <code>init</code> closure. Only one of the calls
evaluates its closure, and other calls wait for that closure to complete.</p>
<p>The following code snippet demonstrates this behavior:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;
<span class="kw">use </span>std::{sync::Arc, thread};

<span class="kw">const </span>TEN_MIB: usize = <span class="number">10 </span>* <span class="number">1024 </span>* <span class="number">1024</span>; <span class="comment">// 10MiB
</span><span class="kw">let </span>cache = Cache::new(<span class="number">100</span>);

<span class="comment">// Spawn four threads.
</span><span class="kw">let </span>threads: Vec&lt;<span class="kw">_</span>&gt; = (<span class="number">0</span>..<span class="number">4_u8</span>)
    .map(|task_id| {
        <span class="kw">let </span>my_cache = cache.clone();
        thread::spawn(<span class="kw">move </span>|| {
            <span class="macro">println!</span>(<span class="string">"Thread {task_id} started."</span>);

            <span class="comment">// Try to insert and get the value for key1. Although all four
            // threads will call `get_with` at the same time, the `init` closure
            // must be evaluated only once.
            </span><span class="kw">let </span>value = my_cache.get_with(<span class="string">"key1"</span>, || {
                <span class="macro">println!</span>(<span class="string">"Thread {task_id} inserting a value."</span>);
                Arc::new(<span class="macro">vec!</span>[<span class="number">0u8</span>; TEN_MIB])
            });

            <span class="comment">// Ensure the value exists now.
            </span><span class="macro">assert_eq!</span>(value.len(), TEN_MIB);
            <span class="macro">assert!</span>(my_cache.get(<span class="kw-2">&amp;</span><span class="string">"key1"</span>).is_some());

            <span class="macro">println!</span>(<span class="string">"Thread {task_id} got the value. (len: {})"</span>, value.len());
        })
    })
    .collect();

<span class="comment">// Wait all threads to complete.
</span>threads
    .into_iter()
    .for_each(|t| t.join().expect(<span class="string">"Thread failed"</span>));</code></pre></div>
<p><strong>Result</strong></p>
<ul>
<li>The <code>init</code> closure was called exactly once by thread 1.</li>
<li>Other threads were blocked until thread 1 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Thread 1 started.
Thread 0 started.
Thread 3 started.
Thread 2 started.
Thread 1 inserting a value.
Thread 2 got the value. (len: 10485760)
Thread 1 got the value. (len: 10485760)
Thread 0 got the value. (len: 10485760)
Thread 3 got the value. (len: 10485760)</code></pre></div><h5 id="panics"><a class="doc-anchor" href="#panics">ยง</a>Panics</h5>
<p>This method panics when the <code>init</code> closure has panicked. When it happens,
only the caller whose <code>init</code> closure panicked will get the panic (e.g. only
thread 1 in the above sample). If there are other calls in progress (e.g.
thread 0, 2 and 3 above), this method will restart and resolve one of the
remaining <code>init</code> closure.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_with_by_ref" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#965-975">Source</a><h4 class="code-header">pub fn <a href="#method.get_with_by_ref" class="fn">get_with_by_ref</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;Q</a>, init: impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V) -&gt; V<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    Q: <a class="trait" href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a>&lt;Owned = K&gt; + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Similar to <a href="#method.get_with"><code>get_with</code></a>, but instead of passing an owned
key, you can pass a reference to the key. If the key does not exist in the
cache, the key will be cloned to create new entry in the cache.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_with_if" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#981-991">Source</a><h4 class="code-header">pub fn <a href="#method.get_with_if" class="fn">get_with_if</a>(
    &amp;self,
    key: K,
    init: impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; V,
    replace_if: impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;V</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.bool.html">bool</a>,
) -&gt; V</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">๐</span><span>Deprecated since 0.10.0: Replaced with <code>entry().or_insert_with_if()</code></span></div></span></summary><div class="docblock"><p>TODO: Remove this in v0.13.0.
Deprecated, replaced with
<a href="./struct.OwnedKeyEntrySelector.html#method.or_insert_with_if"><code>entry()::or_insert_with_if()</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.optionally_get_with" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1187-1196">Source</a><h4 class="code-header">pub fn <a href="#method.optionally_get_with" class="fn">optionally_get_with</a>&lt;F&gt;(&amp;self, key: K, init: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a <em>clone</em> of the value corresponding to the key. If the value does
not exist, evaluates the <code>init</code> closure, and inserts the value if
<code>Some(value)</code> was returned. If <code>None</code> was returned from the closure, this
method does not insert a value and returns <code>None</code>.</p>
<h5 id="concurrent-calls-on-the-same-key-1"><a class="doc-anchor" href="#concurrent-calls-on-the-same-key-1">ยง</a>Concurrent calls on the same key</h5>
<p>This method guarantees that concurrent calls on the same not-existing key are
coalesced into one evaluation of the <code>init</code> closure. Only one of the calls
evaluates its closure, and other calls wait for that closure to complete.</p>
<p>The following code snippet demonstrates this behavior:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;
<span class="kw">use </span>std::{path::Path, thread};

<span class="doccomment">/// This function tries to get the file size in bytes.
</span><span class="kw">fn </span>get_file_size(thread_id: u8, path: <span class="kw">impl </span>AsRef&lt;Path&gt;) -&gt; <span class="prelude-ty">Option</span>&lt;u64&gt; {
    <span class="macro">println!</span>(<span class="string">"get_file_size() called by thread {thread_id}."</span>);
    std::fs::metadata(path).ok().map(|m| m.len())
}

<span class="kw">let </span>cache = Cache::new(<span class="number">100</span>);

<span class="comment">// Spawn four threads.
</span><span class="kw">let </span>threads: Vec&lt;<span class="kw">_</span>&gt; = (<span class="number">0</span>..<span class="number">4_u8</span>)
    .map(|thread_id| {
        <span class="kw">let </span>my_cache = cache.clone();
        thread::spawn(<span class="kw">move </span>|| {
            <span class="macro">println!</span>(<span class="string">"Thread {thread_id} started."</span>);

            <span class="comment">// Try to insert and get the value for key1. Although all four
            // threads will call `optionally_get_with` at the same time,
            // get_file_size() must be called only once.
            </span><span class="kw">let </span>value = my_cache.optionally_get_with(
                <span class="string">"key1"</span>,
                || get_file_size(thread_id, <span class="string">"./Cargo.toml"</span>),
            );

            <span class="comment">// Ensure the value exists now.
            </span><span class="macro">assert!</span>(value.is_some());
            <span class="macro">assert!</span>(my_cache.get(<span class="kw-2">&amp;</span><span class="string">"key1"</span>).is_some());

            <span class="macro">println!</span>(
                <span class="string">"Thread {thread_id} got the value. (len: {})"</span>,
                value.unwrap()
            );
        })
    })
    .collect();

<span class="comment">// Wait all threads to complete.
</span>threads
    .into_iter()
    .for_each(|t| t.join().expect(<span class="string">"Thread failed"</span>));</code></pre></div>
<p><strong>Result</strong></p>
<ul>
<li><code>get_file_size()</code> was called exactly once by thread 0.</li>
<li>Other threads were blocked until thread 0 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Thread 0 started.
Thread 1 started.
Thread 2 started.
get_file_size() called by thread 0.
Thread 3 started.
Thread 2 got the value. (len: 1466)
Thread 0 got the value. (len: 1466)
Thread 1 got the value. (len: 1466)
Thread 3 got the value. (len: 1466)</code></pre></div><h5 id="panics-1"><a class="doc-anchor" href="#panics-1">ยง</a>Panics</h5>
<p>This method panics when the <code>init</code> closure has panicked. When it happens,
only the caller whose <code>init</code> closure panicked will get the panic (e.g. only
thread 1 in the above sample). If there are other calls in progress (e.g.
thread 0, 2 and 3 above), this method will restart and resolve one of the
remaining <code>init</code> closure.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.optionally_get_with_by_ref" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1202-1211">Source</a><h4 class="code-header">pub fn <a href="#method.optionally_get_with_by_ref" class="fn">optionally_get_with_by_ref</a>&lt;F, Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;Q</a>, init: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;,
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    Q: <a class="trait" href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a>&lt;Owned = K&gt; + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Similar to <a href="#method.optionally_get_with"><code>optionally_get_with</code></a>, but instead
of passing an owned key, you can pass a reference to the key. If the key does
not exist in the cache, the key will be cloned to create new entry in the
cache.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_get_with" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1380-1389">Source</a><h4 class="code-header">pub fn <a href="#method.try_get_with" class="fn">try_get_with</a>&lt;F, E&gt;(&amp;self, key: K, init: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, <a class="struct" href="https://doc.rust-lang.org/1.87.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;E&gt;&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, E&gt;,
    E: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h4></section></summary><div class="docblock"><p>Returns a <em>clone</em> of the value corresponding to the key. If the value does
not exist, evaluates the <code>init</code> closure, and inserts the value if <code>Ok(value)</code>
was returned. If <code>Err(_)</code> was returned from the closure, this method does not
insert a value and returns the <code>Err</code> wrapped by <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>std::sync::Arc</code></a>.</p>
<h5 id="concurrent-calls-on-the-same-key-2"><a class="doc-anchor" href="#concurrent-calls-on-the-same-key-2">ยง</a>Concurrent calls on the same key</h5>
<p>This method guarantees that concurrent calls on the same not-existing key are
coalesced into one evaluation of the <code>init</code> closure (as long as these
closures return the same error type). Only one of the calls evaluates its
closure, and other calls wait for that closure to complete.</p>
<p>The following code snippet demonstrates this behavior:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;
<span class="kw">use </span>std::{path::Path, thread};

<span class="doccomment">/// This function tries to get the file size in bytes.
</span><span class="kw">fn </span>get_file_size(thread_id: u8, path: <span class="kw">impl </span>AsRef&lt;Path&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;u64, std::io::Error&gt; {
    <span class="macro">println!</span>(<span class="string">"get_file_size() called by thread {thread_id}."</span>);
    <span class="prelude-val">Ok</span>(std::fs::metadata(path)<span class="question-mark">?</span>.len())
}

<span class="kw">let </span>cache = Cache::new(<span class="number">100</span>);

<span class="comment">// Spawn four threads.
</span><span class="kw">let </span>threads: Vec&lt;<span class="kw">_</span>&gt; = (<span class="number">0</span>..<span class="number">4_u8</span>)
    .map(|thread_id| {
        <span class="kw">let </span>my_cache = cache.clone();
        thread::spawn(<span class="kw">move </span>|| {
            <span class="macro">println!</span>(<span class="string">"Thread {thread_id} started."</span>);

            <span class="comment">// Try to insert and get the value for key1. Although all four
            // threads will call `try_get_with` at the same time,
            // get_file_size() must be called only once.
            </span><span class="kw">let </span>value = my_cache.try_get_with(
                <span class="string">"key1"</span>,
                || get_file_size(thread_id, <span class="string">"./Cargo.toml"</span>),
            );

            <span class="comment">// Ensure the value exists now.
            </span><span class="macro">assert!</span>(value.is_ok());
            <span class="macro">assert!</span>(my_cache.get(<span class="kw-2">&amp;</span><span class="string">"key1"</span>).is_some());

            <span class="macro">println!</span>(
                <span class="string">"Thread {thread_id} got the value. (len: {})"</span>,
                value.unwrap()
            );
        })
    })
    .collect();

<span class="comment">// Wait all threads to complete.
</span>threads
    .into_iter()
    .for_each(|t| t.join().expect(<span class="string">"Thread failed"</span>));</code></pre></div>
<p><strong>Result</strong></p>
<ul>
<li><code>get_file_size()</code> was called exactly once by thread 1.</li>
<li>Other threads were blocked until thread 1 inserted the value.</li>
</ul>
<div class="example-wrap"><pre class="language-console"><code>Thread 1 started.
Thread 2 started.
get_file_size() called by thread 1.
Thread 3 started.
Thread 0 started.
Thread 2 got the value. (len: 1466)
Thread 0 got the value. (len: 1466)
Thread 1 got the value. (len: 1466)
Thread 3 got the value. (len: 1466)</code></pre></div><h5 id="panics-2"><a class="doc-anchor" href="#panics-2">ยง</a>Panics</h5>
<p>This method panics when the <code>init</code> closure has panicked. When it happens,
only the caller whose <code>init</code> closure panicked will get the panic (e.g. only
thread 1 in the above sample). If there are other calls in progress (e.g.
thread 0, 2 and 3 above), this method will restart and resolve one of the
remaining <code>init</code> closure.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_get_with_by_ref" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1394-1404">Source</a><h4 class="code-header">pub fn <a href="#method.try_get_with_by_ref" class="fn">try_get_with_by_ref</a>&lt;F, E, Q&gt;(
    &amp;self,
    key: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;Q</a>,
    init: F,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, <a class="struct" href="https://doc.rust-lang.org/1.87.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;E&gt;&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;V, E&gt;,
    E: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    Q: <a class="trait" href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a>&lt;Owned = K&gt; + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Similar to <a href="#method.try_get_with"><code>try_get_with</code></a>, but instead of passing an
owned key, you can pass a reference to the key. If the key does not exist in
the cache, the key will be cloned to create new entry in the cache.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.insert" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1491-1495">Source</a><h4 class="code-header">pub fn <a href="#method.insert" class="fn">insert</a>(&amp;self, key: K, value: V)</h4></section></summary><div class="docblock"><p>Inserts a key-value pair into the cache.</p>
<p>If the cache has this key present, the value is updated.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.invalidate" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1569-1576">Source</a><h4 class="code-header">pub fn <a href="#method.invalidate" class="fn">invalidate</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;Q</a>)<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    Q: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Discards any cached value for the key.</p>
<p>If you need to get a the value that has been discarded, use the
<a href="#method.remove"><code>remove</code></a> method instead.</p>
<p>The key may be any borrowed form of the cacheโs key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1585-1592">Source</a><h4 class="code-header">pub fn <a href="#method.remove" class="fn">remove</a>&lt;Q&gt;(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;Q</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;V&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt;,
    Q: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Discards any cached value for the key and returns a <em>clone</em> of the value.</p>
<p>If you do not need to get the value that has been discarded, use the
<a href="#method.invalidate"><code>invalidate</code></a> method instead.</p>
<p>The key may be any borrowed form of the cacheโs key type, but <code>Hash</code> and <code>Eq</code>
on the borrowed form <em>must</em> match those for the key type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.invalidate_all" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1676-1678">Source</a><h4 class="code-header">pub fn <a href="#method.invalidate_all" class="fn">invalidate_all</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Discards all cached values.</p>
<p>This method returns immediately by just setting the current time as the
invalidation time. <code>get</code> and other retrieval methods are guaranteed not to
return the entries inserted before or at the invalidation time.</p>
<p>The actual removal of the invalidated entries is done as a maintenance task
driven by a user thread. For more details, see
<a href="../index.html#maintenance-tasks">the Maintenance Tasks section</a> in the crate
level documentation.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.invalidate_entries_if" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1713-1718">Source</a><h4 class="code-header">pub fn <a href="#method.invalidate_entries_if" class="fn">invalidate_entries_if</a>&lt;F&gt;(
    &amp;self,
    predicate: F,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.PredicateId.html" title="type moka::sync::PredicateId">PredicateId</a>, <a class="enum" href="../enum.PredicateError.html" title="enum moka::PredicateError">PredicateError</a>&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;K</a>, <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;V</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.bool.html">bool</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h4></section></summary><div class="docblock"><p>Discards cached values that satisfy a predicate.</p>
<p><code>invalidate_entries_if</code> takes a closure that returns <code>true</code> or <code>false</code>. The
closure is called against each cached entry inserted before or at the time
when this method was called. If the closure returns <code>true</code> that entry will be
evicted from the cache.</p>
<p>This method returns immediately by not actually removing the invalidated
entries. Instead, it just sets the predicate to the cache with the time when
this method was called. The actual removal of the invalidated entries is done
as a maintenance task driven by a user thread. For more details, see
<a href="../index.html#maintenance-tasks">the Maintenance Tasks section</a> in the crate
level documentation.</p>
<p>Also the <code>get</code> and other retrieval methods will apply the closure to a cached
entry to determine if it should have been invalidated. Therefore, it is
guaranteed that these methods must not return invalidated values.</p>
<p>Note that you must call
<a href="./struct.CacheBuilder.html#method.support_invalidation_closures"><code>CacheBuilder::support_invalidation_closures</code></a>
at the cache creation time as the cache needs to maintain additional internal
data structures to support this method. Otherwise, calling this method will
fail with a
<a href="../enum.PredicateError.html#variant.InvalidationClosuresDisabled"><code>PredicateError::InvalidationClosuresDisabled</code></a>.</p>
<p>Like the <code>invalidate</code> method, this method does not clear the historic
popularity estimator of keys so that it retains the client activities of
trying to retrieve an item.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1777-1779">Source</a><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>(&amp;self) -&gt; <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'_, K, V&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;&#39;_, K, V&gt;">โ</a></h4></section></summary><div class="docblock"><p>Creates an iterator visiting all key-value pairs in arbitrary order. The
iterator element type is <code>(Arc&lt;K&gt;, V)</code>, where <code>V</code> is a clone of a stored
value.</p>
<p>Iterators do not block concurrent reads and writes on the cache. An entry can
be inserted to, invalidated or evicted from a cache while iterators are alive
on the same cache.</p>
<p>Unlike the <code>get</code> method, visiting entries via an iterator do not update the
historic popularity estimator or reset idle timers for keys.</p>
<h5 id="guarantees"><a class="doc-anchor" href="#guarantees">ยง</a>Guarantees</h5>
<p>In order to allow concurrent access to the cache, iteratorโs <code>next</code> method
does <em>not</em> guarantee the following:</p>
<ul>
<li>It does not guarantee to return a key-value pair (an entry) if its key has
been inserted to the cache <em>after</em> the iterator was created.
<ul>
<li>Such an entry may or may not be returned depending on keyโs hash and
timing.</li>
</ul>
</li>
</ul>
<p>and the <code>next</code> method guarantees the followings:</p>
<ul>
<li>It guarantees not to return the same entry more than once.</li>
<li>It guarantees not to return an entry if it has been removed from the cache
after the iterator was created.
<ul>
<li>Note: An entry can be removed by following reasons:
<ul>
<li>Manually invalidated.</li>
<li>Expired (e.g. time-to-live).</li>
<li>Evicted as the cache capacity exceeded.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="examples"><a class="doc-anchor" href="#examples">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>moka::sync::Cache;

<span class="kw">let </span>cache = Cache::new(<span class="number">100</span>);
cache.insert(<span class="string">"Julia"</span>, <span class="number">14</span>);

<span class="kw">let </span><span class="kw-2">mut </span>iter = cache.iter();
<span class="kw">let </span>(k, v) = iter.next().unwrap(); <span class="comment">// (Arc&lt;K&gt;, V)
</span><span class="macro">assert_eq!</span>(<span class="kw-2">*</span>k, <span class="string">"Julia"</span>);
<span class="macro">assert_eq!</span>(v, <span class="number">14</span>);

<span class="macro">assert!</span>(iter.next().is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.run_pending_tasks" class="method"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1782-1786">Source</a><h4 class="code-header">pub fn <a href="#method.run_pending_tasks" class="fn">run_pending_tasks</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Performs any pending maintenance operations needed by the cache.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">ยง</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Cache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#597-608">Source</a><a href="#impl-Clone-for-Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#602-607">Source</a><a href="#method.clone" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class="docblock"><p>Makes a clone of this shared cache.</p>
<p>This operation is cheap as it only creates thread-safe reference counted
pointers to the shared internal data structures.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ยท <a class="src" href="https://doc.rust-lang.org/1.87.0/src/core/clone.rs.html#174">Source</a></span><a href="#method.clone_from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Cache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#610-626">Source</a><a href="#impl-Debug-for-Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    V: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    S: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#617-625">Source</a><a href="#method.fmt" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.87.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.87.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.87.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoIterator-for-%26Cache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1789-1802">Source</a><a href="#impl-IntoIterator-for-%26Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;'a, K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    V: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,
    S: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/hash/trait.BuildHasher.html" title="trait core::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> + 'static,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1795">Source</a><a href="#associatedtype.Item" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = (<a class="struct" href="https://doc.rust-lang.org/1.87.0/alloc/sync/struct.Arc.html" title="struct alloc::sync::Arc">Arc</a>&lt;K&gt;, V)</h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1797">Source</a><a href="#associatedtype.IntoIter" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.Iter.html" title="struct moka::sync::Iter">Iter</a>&lt;'a, K, V&gt;</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#1799-1801">Source</a><a href="#method.into_iter" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.87.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><section id="impl-Send-for-Cache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#580-586">Source</a><a href="#impl-Send-for-Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    V: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    S: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-Cache%3CK,+V,+S%3E" class="impl"><a class="src rightside" href="../../src/moka/sync/cache.rs.html#588-594">Source</a><a href="#impl-Sync-for-Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;<div class="where">where
    K: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    V: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    S: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">ยง</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Cache%3CK,+V,+S%3E" class="impl"><a href="#impl-Freeze-for-Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section><section id="impl-RefUnwindSafe-for-Cache%3CK,+V,+S%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S = <a class="struct" href="https://doc.rust-lang.org/1.87.0/std/hash/random/struct.RandomState.html" title="struct std::hash::random::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section><section id="impl-Unpin-for-Cache%3CK,+V,+S%3E" class="impl"><a href="#impl-Unpin-for-Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section><section id="impl-UnwindSafe-for-Cache%3CK,+V,+S%3E" class="impl"><a href="#impl-UnwindSafe-for-Cache%3CK,+V,+S%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;K, V, S = <a class="struct" href="https://doc.rust-lang.org/1.87.0/std/hash/random/struct.RandomState.html" title="struct std::hash::random::RandomState">RandomState</a>&gt; !<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Cache.html" title="struct moka::sync::Cache">Cache</a>&lt;K, V, S&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">ยง</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.87.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.87.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.87.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/clone.rs.html#441">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/clone.rs.html#443">Source</a><a href="#method.clone_to_uninit" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">๐ฌ</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/1.87.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#767">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#770">Source</a><a href="#method.from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#750-752">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#760">Source</a><a href="#method.into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#194">Source</a><a href="#impl-Pointable-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#195">Source</a><a href="#associatedconstant.ALIGN" class="anchor">ยง</a><h4 class="code-header">const <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#associatedconstant.ALIGN" class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#197">Source</a><a href="#associatedtype.Init" class="anchor">ยง</a><h4 class="code-header">type <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#199">Source</a><a href="#method.init" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init" class="fn">init</a>(init: &lt;T as <a class="trait" href="../../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a>&gt;::<a class="associatedtype" href="../../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" title="type crossbeam_epoch::atomic::Pointable::Init">Init</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#203">Source</a><a href="#method.deref" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref" class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#207">Source</a><a href="#method.deref_mut" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut" class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#211">Source</a><a href="#method.drop" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop" class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.87.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#806-808">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#810">Source</a><a href="#associatedtype.Error-1" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#813">Source</a><a href="#method.try_from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#791-793">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#795">Source</a><a href="#associatedtype.Error" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.87.0/src/core/convert/mod.rs.html#798">Source</a><a href="#method.try_into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.87.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"Iter<'_, K, V>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct moka::sync::Iter\">Iter</a>&lt;'_, K, V&gt;</code></h3><pre><code><div class=\"where\">impl&lt;K, V&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct moka::sync::Iter\">Iter</a>&lt;'_, K, V&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,\n    V: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.87.0/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> + 'static,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.87.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"struct\" href=\"https://doc.rust-lang.org/1.87.0/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\">Arc</a>&lt;K&gt;, V);</div>"}</script></section></div></main></body></html>