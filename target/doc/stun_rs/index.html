<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="STUN library."><title>stun_rs - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="stun_rs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../stun_rs/index.html">stun_rs</a><span class="version">0.1.11</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#common-features" title="Common features">Common features</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>stun_rs</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/stun_rs/lib.rs.html#1-272">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>STUN library.</p>
<p>This crate provides a simple framework to manage STUN protocol.
The implementation is based on:</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8489"><code>RFC8489</code></a>. Session Traversal Utilities for NAT (STUN).</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8445"><code>RFC8445</code></a>. Interactive Connectivity Establishment (ICE).</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8656"><code>RFC8656</code></a>. Traversal Using Relays around NAT (TURN).</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc5769"><code>RFC5769</code></a>. Test Vectors for Session Traversal Utilities for NAT (STUN).</li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8016"><code>RFC8016</code></a>. Mobility with Traversal Using Relays around NAT (TURN).</li>
</ul>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p>Example that creates and encodes a STUN Binding request</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// Create attributes
 </span><span class="kw">let </span>username = UserName::new(<span class="string">"\u{30DE}\u{30C8}\u{30EA}\u{30C3}\u{30AF}\u{30B9}"</span>)<span class="question-mark">?</span>;
 <span class="kw">let </span>nonce = Nonce::new(<span class="string">"f//499k954d6OL34oL9FSTvy64sA"</span>)<span class="question-mark">?</span>;
 <span class="kw">let </span>realm = Realm::new(<span class="string">"example.org"</span>)<span class="question-mark">?</span>;
 <span class="kw">let </span>password = <span class="string">"TheMatrIX"</span>;
 <span class="kw">let </span>algorithm = Algorithm::from(AlgorithmId::MD5);
 <span class="kw">let </span>key = HMACKey::new_long_term(<span class="kw-2">&amp;</span>username, <span class="kw-2">&amp;</span>realm, password, algorithm)<span class="question-mark">?</span>;
 <span class="kw">let </span>integrity = MessageIntegrity::new(key);

 <span class="comment">// Create the message
 </span><span class="kw">let </span>msg = StunMessageBuilder::new(
   BINDING,
   MessageClass::Request,
 )
 .with_attribute(username)
 .with_attribute(nonce)
 .with_attribute(realm)
 .with_attribute(integrity)
 .build();

 <span class="comment">// Create an encoder to encode the message into a buffer
 </span><span class="kw">let </span>encoder = MessageEncoderBuilder::default().build();
 <span class="kw">let </span><span class="kw-2">mut </span>buffer: [u8; <span class="number">150</span>] = [<span class="number">0x00</span>; <span class="number">150</span>];
 <span class="kw">let </span>size = encoder.encode(<span class="kw-2">&amp;mut </span>buffer, <span class="kw-2">&amp;</span>msg)<span class="question-mark">?</span>;
 <span class="macro">assert_eq!</span>(size, <span class="number">116</span>);</code></pre></div>
<p>Example that decodes a STUN Binding response and fetches some attributes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="comment">// This response uses the following parameter:
 // Password: `VOkJxbRl1RmTxUk/WvJxBt` (without quotes)
 // Software name: "test vector" (without quotes)
 // Mapped address: 192.0.2.1 port 32853
 </span><span class="kw">let </span>sample_ipv4_response = [
     <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x3c</span>, <span class="comment">// Response type and message length
     </span><span class="number">0x21</span>, <span class="number">0x12</span>, <span class="number">0xa4</span>, <span class="number">0x42</span>, <span class="comment">// Magic cookie
     </span><span class="number">0xb7</span>, <span class="number">0xe7</span>, <span class="number">0xa7</span>, <span class="number">0x01</span>, <span class="comment">// }
     </span><span class="number">0xbc</span>, <span class="number">0x34</span>, <span class="number">0xd6</span>, <span class="number">0x86</span>, <span class="comment">// }  Transaction ID
     </span><span class="number">0xfa</span>, <span class="number">0x87</span>, <span class="number">0xdf</span>, <span class="number">0xae</span>, <span class="comment">// }
     </span><span class="number">0x80</span>, <span class="number">0x22</span>, <span class="number">0x00</span>, <span class="number">0x0b</span>, <span class="comment">// SOFTWARE attribute header
     </span><span class="number">0x74</span>, <span class="number">0x65</span>, <span class="number">0x73</span>, <span class="number">0x74</span>, <span class="comment">// }
     </span><span class="number">0x20</span>, <span class="number">0x76</span>, <span class="number">0x65</span>, <span class="number">0x63</span>, <span class="comment">// }  UTF-8 server name
     </span><span class="number">0x74</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x20</span>, <span class="comment">// }
     </span><span class="number">0x00</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="comment">// XOR-MAPPED-ADDRESS attribute header
     </span><span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0xa1</span>, <span class="number">0x47</span>, <span class="comment">// Address family (IPv4) and xor'd mapped port number
     </span><span class="number">0xe1</span>, <span class="number">0x12</span>, <span class="number">0xa6</span>, <span class="number">0x43</span>, <span class="comment">// Xor'd mapped IPv4 address
     </span><span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x14</span>, <span class="comment">// MESSAGE-INTEGRITY header
     </span><span class="number">0x2b</span>, <span class="number">0x91</span>, <span class="number">0xf5</span>, <span class="number">0x99</span>, <span class="comment">// }
     </span><span class="number">0xfd</span>, <span class="number">0x9e</span>, <span class="number">0x90</span>, <span class="number">0xc3</span>, <span class="comment">// }
     </span><span class="number">0x8c</span>, <span class="number">0x74</span>, <span class="number">0x89</span>, <span class="number">0xf9</span>, <span class="comment">// } HMAC-SHA1 fingerprint
     </span><span class="number">0x2a</span>, <span class="number">0xf9</span>, <span class="number">0xba</span>, <span class="number">0x53</span>, <span class="comment">// }
     </span><span class="number">0xf0</span>, <span class="number">0x6b</span>, <span class="number">0xe7</span>, <span class="number">0xd7</span>, <span class="comment">// }
     </span><span class="number">0x80</span>, <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="comment">// FINGERPRINT attribute header
     </span><span class="number">0xc0</span>, <span class="number">0x7d</span>, <span class="number">0x4c</span>, <span class="number">0x96</span>, <span class="comment">// Reserved for CRC32 fingerprint
 </span>];

 <span class="comment">// Create a STUN decoder context using the password as a short credential
 // mechanism and force validation of MESSAGE-INTEGRITY and FINGERPRINT
 </span><span class="kw">let </span>ctx = DecoderContextBuilder::default()
   .with_key(
     HMACKey::new_short_term(<span class="string">"VOkJxbRl1RmTxUk/WvJxBt"</span>)<span class="question-mark">?</span>,
   )
   .with_validation()
   .build();
 <span class="kw">let </span>decoder = MessageDecoderBuilder::default().with_context(ctx).build();

 <span class="kw">let </span>(msg, size) = decoder.decode(<span class="kw-2">&amp;</span>sample_ipv4_response)<span class="question-mark">?</span>;
 <span class="macro">assert_eq!</span>(size, sample_ipv4_response.len());

 <span class="comment">// Check message method is a BINDING response
 </span><span class="macro">assert_eq!</span>(msg.method(), BINDING);
 <span class="macro">assert_eq!</span>(msg.class(), MessageClass::SuccessResponse);

 <span class="kw">let </span>software = msg.get::&lt;Software&gt;()
   .ok_or(<span class="string">"Software attribute not found"</span>)<span class="question-mark">?
   </span>.as_software()<span class="question-mark">?</span>;
 <span class="macro">assert_eq!</span>(software, <span class="string">"test vector"</span>);

 <span class="kw">let </span>xor_addr = msg.get::&lt;XorMappedAddress&gt;()
   .ok_or(<span class="string">"XorMappedAddress attribute not found"</span>)<span class="question-mark">?
   </span>.as_xor_mapped_address()<span class="question-mark">?</span>;
 <span class="kw">let </span>socket = xor_addr.socket_address();
 <span class="macro">assert_eq!</span>(socket.ip(), IpAddr::V4(Ipv4Addr::new(<span class="number">192</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)));
 <span class="macro">assert_eq!</span>(socket.port(), <span class="number">32853</span>);
 <span class="macro">assert!</span>(socket.is_ipv4());</code></pre></div>
<h2 id="common-features"><a class="doc-anchor" href="#common-features">§</a>Common features</h2>
<p>This crate defines next feature flags that can be enabled:</p>
<ul>
<li><strong>turn</strong>: Extends support for parsing attributes defined in
<a href="https://datatracker.ietf.org/doc/html/rfc8656"><code>RFC8656</code></a>.
Traversal Using Relays around NAT (TURN).</li>
<li><strong>ice</strong>: Extends support for parsing attributes defined in
<a href="https://datatracker.ietf.org/doc/html/rfc8445"><code>RFC8445</code></a>.
Interactive Connectivity Establishment (ICE).</li>
<li><strong>mobility</strong>: Extends support for parsing attributes defined in
<a href="https://datatracker.ietf.org/doc/html/rfc8016"><code>RFC8016</code></a>.
Mobility with Traversal Using Relays around NAT (TURN).</li>
<li><strong>experiments</strong>: This flag can be set to adjust some behavior
of the library, such as default padding. When testing protocols,
we can use this flag to force the library to keep the data
associated with <a href="attributes/struct.Unknown.html" title="struct stun_rs::attributes::Unknown">Unknown</a> attributes.
By default, <a href="attributes/struct.Unknown.html" title="struct stun_rs::attributes::Unknown">Unknown</a> attributes
store no data to save memory consumption.</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.AttributeType"><code>pub use crate::attributes::<a class="struct" href="attributes/struct.AttributeType.html" title="struct stun_rs::attributes::AttributeType">AttributeType</a>;</code></dt><dt id="reexport.StunAttribute"><code>pub use crate::attributes::<a class="enum" href="attributes/enum.StunAttribute.html" title="enum stun_rs::attributes::StunAttribute">StunAttribute</a>;</code></dt><dt id="reexport.StunAttributeType"><code>pub use crate::attributes::<a class="trait" href="attributes/trait.StunAttributeType.html" title="trait stun_rs::attributes::StunAttributeType">StunAttributeType</a>;</code></dt><dt id="reexport.StunError"><code>pub use crate::error::<a class="struct" href="error/struct.StunError.html" title="struct stun_rs::error::StunError">StunError</a>;</code></dt><dt id="reexport.StunErrorType"><code>pub use crate::error::<a class="enum" href="error/enum.StunErrorType.html" title="enum stun_rs::error::StunErrorType">StunErrorType</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="attributes/index.html" title="mod stun_rs::attributes">attributes</a></dt><dd>STUN Attributes.
This module contains all attributes defined for the STUN protocol.
Additional flags can be enabled for TURN and ICE.</dd><dt><a class="mod" href="error/index.html" title="mod stun_rs::error">error</a></dt><dd>STUN Errors.
This module contains all errors that can happen when dealing with stun.</dd><dt><a class="mod" href="methods/index.html" title="mod stun_rs::methods">methods</a></dt><dd>STUN Methods Registry</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Algorithm.html" title="struct stun_rs::Algorithm">Algorithm</a></dt><dd>An algorithm is the combination of the <a href="enum.AlgorithmId.html" title="enum stun_rs::AlgorithmId"><code>AlgorithmId</code></a> and its parameters.</dd><dt><a class="struct" href="struct.Cookie.html" title="struct stun_rs::Cookie">Cookie</a></dt><dd>STUN message cookie</dd><dt><a class="struct" href="struct.DecoderContext.html" title="struct stun_rs::DecoderContext">Decoder<wbr>Context</a></dt><dd>Context used to decode STUN messages</dd><dt><a class="struct" href="struct.DecoderContextBuilder.html" title="struct stun_rs::DecoderContextBuilder">Decoder<wbr>Context<wbr>Builder</a></dt><dd>Builder class used to construct <a href="struct.DecoderContext.html" title="struct stun_rs::DecoderContext"><code>DecoderContext</code></a> objects</dd><dt><a class="struct" href="struct.EncoderContext.html" title="struct stun_rs::EncoderContext">Encoder<wbr>Context</a></dt><dd>Context used to decode STUN messages that requires special
treatment like <code>CRC</code> or integrity validations</dd><dt><a class="struct" href="struct.EncoderContextBuilder.html" title="struct stun_rs::EncoderContextBuilder">Encoder<wbr>Context<wbr>Builder</a></dt><dd>Builder class used to construct <a href="struct.EncoderContext.html" title="struct stun_rs::EncoderContext"><code>EncoderContext</code></a> objects</dd><dt><a class="struct" href="struct.ErrorCode.html" title="struct stun_rs::ErrorCode">Error<wbr>Code</a></dt><dd>The <code>ErrorCode</code> contains a numeric error code value in the range of 300
to 699 plus a textual reason phrase encoded in UTF-8
<a href="https://datatracker.ietf.org/doc/html/rfc3629"><code>RFC3629</code></a>; it is also
consistent in its code assignments and semantics with SIP
<a href="https://datatracker.ietf.org/doc/html/rfc3261"><code>RFC3261</code></a>
and HTTP <a href="https://datatracker.ietf.org/doc/html/rfc7231"><code>RFC7231</code></a>.
The reason phrase is meant for diagnostic purposes and can be anything
appropriate for the error code.
Recommended reason phrases for the defined error codes are included
in the <code>IANA</code> registry for error codes.  The reason phrase MUST be a
UTF-8-encoded <a href="https://datatracker.ietf.org/doc/html/rfc3629"><code>RFC3629</code></a>
sequence of fewer than 128 characters (which can be as long as 509 bytes
when encoding them or 763 bytes when decoding them).</dd><dt><a class="struct" href="struct.HMACKey.html" title="struct stun_rs::HMACKey">HMACKey</a></dt><dd>Key used for authentication and message integrity</dd><dt><a class="struct" href="struct.MessageDecoder.html" title="struct stun_rs::MessageDecoder">Message<wbr>Decoder</a></dt><dd>Class used to decode STUN messages</dd><dt><a class="struct" href="struct.MessageDecoderBuilder.html" title="struct stun_rs::MessageDecoderBuilder">Message<wbr>Decoder<wbr>Builder</a></dt><dd>Builder class used to create a stun <a href="struct.MessageDecoder.html" title="struct stun_rs::MessageDecoder"><code>MessageDecoder</code></a></dd><dt><a class="struct" href="struct.MessageEncoder.html" title="struct stun_rs::MessageEncoder">Message<wbr>Encoder</a></dt><dd>Class used to encode STUN messages</dd><dt><a class="struct" href="struct.MessageEncoderBuilder.html" title="struct stun_rs::MessageEncoderBuilder">Message<wbr>Encoder<wbr>Builder</a></dt><dd>Builder class used to create a stun <a href="struct.MessageEncoder.html" title="struct stun_rs::MessageEncoder"><code>MessageEncoder</code></a></dd><dt><a class="struct" href="struct.MessageHeader.html" title="struct stun_rs::MessageHeader">Message<wbr>Header</a></dt><dd>The STUN message header</dd><dt><a class="struct" href="struct.MessageMethod.html" title="struct stun_rs::MessageMethod">Message<wbr>Method</a></dt><dd>The STUN method is a 12 bits hex number in the range 0x000-0xFFF but
valid values are defined in the range 0x00-0xFF.
STUN methods in the range 0x000-0x07F are assigned by <code>IETF</code> Review
<a href="https://datatracker.ietf.org/doc/html/rfc8126"><code>RFC8126</code></a>. STUN
methods in the range 0x080-0x0FF are assigned by Expert Review.</dd><dt><a class="struct" href="struct.MessageType.html" title="struct stun_rs::MessageType">Message<wbr>Type</a></dt><dd>The message type defines the message class (request, success
response, error response, or indication) and the message method (the
primary function) of the STUN message.  Although there are four
message classes, there are only two types of transactions in STUN:
request/response transactions (which consist of a request message and
a response message) and indication transactions (which consist of a
single indication message).  Response classes are split into error
and success responses to aid in quickly processing the STUN message.</dd><dt><a class="struct" href="struct.StunMessage.html" title="struct stun_rs::StunMessage">Stun<wbr>Message</a></dt><dd>The stun message is the basic unit of information interchanged between
two agents implementing the STUN protocol.</dd><dt><a class="struct" href="struct.StunMessageBuilder.html" title="struct stun_rs::StunMessageBuilder">Stun<wbr>Message<wbr>Builder</a></dt><dd>The <a href="struct.StunMessageBuilder.html" title="struct stun_rs::StunMessageBuilder"><code>StunMessageBuilder</code></a> ease the creation of a <a href="struct.StunMessage.html" title="struct stun_rs::StunMessage"><code>StunMessage</code></a></dd><dt><a class="struct" href="struct.TransactionId.html" title="struct stun_rs::TransactionId">Transaction<wbr>Id</a></dt><dd>The transaction ID is a 96-bit identifier, used to uniquely identify
STUN transactions. It primarily serves to correlate requests with
responses, though it also plays a small role in helping to prevent
certain types of attacks. The server also uses the transaction ID as
a key to identify each transaction uniquely across all clients.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AddressFamily.html" title="enum stun_rs::AddressFamily">Address<wbr>Family</a></dt><dd>Address family</dd><dt><a class="enum" href="enum.AlgorithmId.html" title="enum stun_rs::AlgorithmId">Algorithm<wbr>Id</a></dt><dd><a href="https://datatracker.ietf.org/doc/html/rfc8489#section-18.5">STUN Password Algorithms</a></dd><dt><a class="enum" href="enum.CredentialMechanism.html" title="enum stun_rs::CredentialMechanism">Credential<wbr>Mechanism</a></dt><dd>Authentication and message-integrity mechanisms.
The STUN <a href="https://datatracker.ietf.org/doc/html/rfc8489"><code>RFC8489</code></a>
defines two mechanisms for STUN that a client and server
can use to provide authentication and message integrity; these two
mechanisms are known as the short-term credential mechanism and the
long-term credential mechanism.  These two mechanisms are optional,
and each usage must specify if and when these mechanisms are used.</dd><dt><a class="enum" href="enum.MessageClass.html" title="enum stun_rs::MessageClass">Message<wbr>Class</a></dt><dd>The STUN message class. Although there are four
message classes, there are only two types of transactions in STUN:
request/response transactions (which consist of a request message and
a response message) and indication transactions (which consist of a
single indication message).  Response classes are split into error
and success responses to aid in quickly processing the STUN message.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.MAGIC_COOKIE.html" title="constant stun_rs::MAGIC_COOKIE">MAGIC_<wbr>COOKIE</a></dt><dd>STUN magic cookie</dd><dt><a class="constant" href="constant.MESSAGE_HEADER_SIZE.html" title="constant stun_rs::MESSAGE_HEADER_SIZE">MESSAGE_<wbr>HEADER_<wbr>SIZE</a></dt><dd>STUN message header size</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.get_input_text.html" title="fn stun_rs::get_input_text">get_<wbr>input_<wbr>text</a></dt><dd>Gets the input text used by attributes that requires validation.
The text used as input for validation is the STUN message,
up to and including the attribute preceding the specified attribute.
The Length field of the STUN message header is adjusted to
point to the end of the value of this attribute.</dd></dl></section></div></main></body></html>