<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementation of the iroh-gossip protocol, as an IO-less state machine"><title>iroh_gossip::proto - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="iroh_gossip" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../static.files/storage-82c7156e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../iroh_gossip/index.html">iroh_<wbr>gossip</a><span class="version">0.90.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module proto</a></h2><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate iroh_<wbr>gossip</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">iroh_gossip</a></div><h1>Module <span>proto</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/iroh_gossip/proto.rs.html#1-345">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implementation of the iroh-gossip protocol, as an IO-less state machine</p>
<p>This module implements the iroh-gossip protocol. The entry point is <a href="state/struct.State.html" title="struct iroh_gossip::proto::state::State"><code>State</code></a>, which contains
the protocol state for a node.</p>
<p>The iroh-gossip protocol is made up from two parts: A swarm membership protocol, based on
<a href="https://asc.di.fct.unl.pt/~jleitao/pdf/dsn07-leitao.pdf">HyParView</a>, and a gossip broadcasting protocol, based on <a href="https://asc.di.fct.unl.pt/~jleitao/pdf/srds07-leitao.pdf">PlumTree</a>.</p>
<p>For a full explanation it is recommended to read the two papers. What follows is a brief
outline of the protocols.</p>
<p>All protocol messages are namespaced by a <a href="state/struct.TopicId.html" title="struct iroh_gossip::proto::state::TopicId"><code>TopicId</code></a>, a 32 byte identifier. Topics are
separate swarms and broadcast scopes. The HyParView and PlumTree algorithms both work in the
scope of a single topic. Thus, joining multiple topics increases the number of open connections
to peers and the size of the local routing table.</p>
<p>The <strong>membership protocol</strong> (<a href="https://asc.di.fct.unl.pt/~jleitao/pdf/dsn07-leitao.pdf">HyParView</a>) is a cluster protocol where each peer
maintains a partial view of all nodes in the swarm.
A peer joins the swarm for a topic by connecting to any known peer that is a member of this
topic’s swarm. Obtaining this initial contact info happens out of band. The peer then sends
a <code>Join</code> message to that initial peer. All peers maintain a list of
<code>active</code> and <code>passive</code> peers. Active peers are those that you maintain active connections to.
Passive peers is an addressbook of additional peers. If one of your active peers goes offline,
its slot is filled with a random peer from the passive set. In the default configuration, the
active view has a size of 5 and the passive view a size of 30.
The HyParView protocol ensures that active connections are always bidirectional, and regularly
exchanges nodes for the passive view in a <code>Shuffle</code> operation.
Thus, this protocol exposes a high degree of reliability and auto-recovery in the case of node
failures.</p>
<p>The <strong>gossip protocol</strong> (<a href="https://asc.di.fct.unl.pt/~jleitao/pdf/srds07-leitao.pdf">PlumTree</a>) builds upon the membership protocol. It exposes
a method to broadcast messages to all peers in the swarm. On each node, it maintains two sets
of peers: An <code>eager</code> set and a <code>lazy</code> set. Both are subsets of the <code>active</code> view from the
membership protocol. When broadcasting a message from the local node, or upon receiving a
broadcast message, the message is pushed to all peers in the eager set. Additionally, the hash
of the message (which uniquely identifies it), but not the message content, is lazily pushed
to all peers  in the <code>lazy</code> set. When receiving such lazy pushes (called <code>Ihaves</code>), those peers
may request the message content after a timeout if they didn’t receive the message by one of
their eager peers before. When requesting a message from a currently-lazy peer, this peer is
also upgraded to be an eager peer from that moment on. This strategy self-optimizes the
messaging graph by latency. Note however that this optimization will work best if the messaging
paths are stable, i.e. if it’s always the same peer that broadcasts. If not, the relative
message redundancy will grow and the ideal messaging graph might change frequently.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.InEvent"><code>pub use state::<a class="enum" href="state/enum.InEvent.html" title="enum iroh_gossip::proto::state::InEvent">InEvent</a>;</code></dt><dt id="reexport.Message"><code>pub use state::<a class="struct" href="state/struct.Message.html" title="struct iroh_gossip::proto::state::Message">Message</a>;</code></dt><dt id="reexport.OutEvent"><code>pub use state::<a class="enum" href="state/enum.OutEvent.html" title="enum iroh_gossip::proto::state::OutEvent">OutEvent</a>;</code></dt><dt id="reexport.State"><code>pub use state::<a class="struct" href="state/struct.State.html" title="struct iroh_gossip::proto::state::State">State</a>;</code></dt><dt id="reexport.Timer"><code>pub use state::<a class="struct" href="state/struct.Timer.html" title="struct iroh_gossip::proto::state::Timer">Timer</a>;</code></dt><dt id="reexport.TopicId"><code>pub use state::<a class="struct" href="state/struct.TopicId.html" title="struct iroh_gossip::proto::state::TopicId">TopicId</a>;</code></dt><dt id="reexport.Command"><code>pub use topic::<a class="enum" href="topic/enum.Command.html" title="enum iroh_gossip::proto::topic::Command">Command</a>;</code></dt><dt id="reexport.Config"><code>pub use topic::<a class="struct" href="topic/struct.Config.html" title="struct iroh_gossip::proto::topic::Config">Config</a>;</code></dt><dt id="reexport.Event"><code>pub use topic::<a class="enum" href="topic/enum.Event.html" title="enum iroh_gossip::proto::topic::Event">Event</a>;</code></dt><dt id="reexport.IO"><code>pub use topic::<a class="trait" href="topic/trait.IO.html" title="trait iroh_gossip::proto::topic::IO">IO</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="state/index.html" title="mod iroh_gossip::proto::state">state</a></dt><dd>The protocol state of the <code>iroh-gossip</code> protocol.</dd><dt><a class="mod" href="topic/index.html" title="mod iroh_gossip::proto::topic">topic</a></dt><dd>This module contains the implementation of the gossiping protocol for an individual topic</dd><dt><a class="mod" href="util/index.html" title="mod iroh_gossip::proto::util">util</a></dt><dd>Utilities used in the protocol implementation</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.HyparviewConfig.html" title="struct iroh_gossip::proto::HyparviewConfig">Hyparview<wbr>Config</a></dt><dd>Configuration for the swarm membership layer</dd><dt><a class="struct" href="struct.PeerData.html" title="struct iroh_gossip::proto::PeerData">Peer<wbr>Data</a></dt><dd>Opaque binary data that is transmitted on messages that introduce new peers.</dd><dt><a class="struct" href="struct.PlumtreeConfig.html" title="struct iroh_gossip::proto::PlumtreeConfig">Plumtree<wbr>Config</a></dt><dd>Configuration for the gossip broadcast layer.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.DeliveryScope.html" title="enum iroh_gossip::proto::DeliveryScope">Delivery<wbr>Scope</a></dt><dd>The scope to deliver the message to.</dd><dt><a class="enum" href="enum.Scope.html" title="enum iroh_gossip::proto::Scope">Scope</a></dt><dd>The broadcast scope of a gossip message.</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.DEFAULT_MAX_MESSAGE_SIZE.html" title="constant iroh_gossip::proto::DEFAULT_MAX_MESSAGE_SIZE">DEFAULT_<wbr>MAX_<wbr>MESSAGE_<wbr>SIZE</a></dt><dd>The default maximum size in bytes for a gossip message.
This is a sane but arbitrary default and can be changed in the <a href="topic/struct.Config.html" title="struct iroh_gossip::proto::topic::Config"><code>Config</code></a>.</dd><dt><a class="constant" href="constant.MIN_MAX_MESSAGE_SIZE.html" title="constant iroh_gossip::proto::MIN_MAX_MESSAGE_SIZE">MIN_<wbr>MAX_<wbr>MESSAGE_<wbr>SIZE</a></dt><dd>The minimum allowed value for <a href="topic/struct.Config.html#structfield.max_message_size" title="field iroh_gossip::proto::topic::Config::max_message_size"><code>Config::max_message_size</code></a>.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.PeerIdentity.html" title="trait iroh_gossip::proto::PeerIdentity">Peer<wbr>Identity</a></dt><dd>The identifier for a peer.</dd></dl></section></div></main></body></html>